/*
  xsns_99_pilotwire.ino - French Pilot Wire (Fil Pilote) support (~27.5 kb)
  for Sonoff Basic or Sonoff Dual R2

  Copyright (C) 2019/2020  Theo Arends, Nicolas Bernaerts
    05/04/2019 - v1.0  - Creation
    12/04/2019 - v1.1  - Save settings in Settings.weight... variables
    10/06/2019 - v2.0  - Complete rewrite to add web management
    25/06/2019 - v2.1  - Add DHT temperature sensor and settings validity control
    05/07/2019 - v2.2  - Add embeded icon
    05/07/2019 - v3.0  - Add max power management with automatic offload
                         Save power settings in Settings.energy... variables
    12/12/2019 - v3.1  - Add public configuration page http://.../control
    30/12/2019 - v4.0  - Functions rewrite for Tasmota 8.x compatibility
    06/01/2019 - v4.1  - Handle offloading with finite state machine
    09/01/2019 - v4.2  - Separation between Offloading driver and Pilotwire sensor
    15/01/2020 - v5.0  - Separate temperature driver and add remote MQTT sensor
    05/02/2020 - v5.1  - Block relay command if not coming from a mode set
    21/02/2020 - v5.2  - Add daily temperature graph
    24/02/2020 - v5.3  - Add control button to main page
    27/02/2020 - v5.4  - Add target temperature and relay state to temperature graph
    01/03/2020 - v5.5  - Add timer management with Outside mode
    13/03/2020 - v5.6  - Add time to graph
    05/04/2020 - v5.7  - Add timezone management
    18/04/2020 - v6.0  - Handle direct connexion of heater in addition to pilotwire
    22/08/2020 - v6.1  - Handle out of range values during first flash
    24/08/2020 - v6.5  - Add status icon to Web UI 
    12/09/2020 - v6.6  - Add offload icon status 
    10/10/2020 - v6.8  - Handle graph with javascript auto update 
    14/10/2020 - v6.9  - Serve icons thru web server 
    18/10/2020 - v6.10 - Handle priorities as list of device types
                         Add randomisation to reconnexion
    04/11/2020 - v6.11 - Tasmota 9.0 compatibility
    11/11/2020 - v6.12 - Update to Offload v2.5
                         Add /data.json for history data
    23/04/2021 - v6.20 - Add fixed IP and remove use of String to avoid heap fragmentation
    20/06/2021 - v6.21 - Change in remote temperature sensor management (thanks to Bernard Monot) 
    04/09/2021 - v7.0  - Save configuration and historical data in LittleFS partition if available
    15/11/2021 - v7.1  - Redesign of control page and based on Tasmota 10.0
    15/11/2021 - v8.0  - Merge Offload and Pilotwire projects, based on Tasmota 10
                         Add movement detection with Nobody and Vacancy mode
                         Redesign of pilotwire control page
    02/01/2022 - v9.0  - Complete rework to simplify states
                         Add Open Window detection
  
  If LittleFS partition is available, settings are stored in /pilotwire.cfg and /offload.cfg

  If no LittleFS partition is available, settings are stored using knx_CB_addr parameters :
    - Settings.knx_CB_addr[0]   = Device type (pilotewire or direct)
    - Settings.knx_CB_addr[1]   = Pilotwire mode
    - Settings.knx_CB_addr[2]   = Minimum temperature (x10 -> 125 = 12.5°C)
    - Settings.knx_CB_addr[3]   = Maximum temperature (x10 -> 240 = 24.0°C)
    - Settings.knx_CB_addr[4]   = Thermostat target temperature (x10 -> 185 = 18.5°C)

    - Settings.knx_CB_addr[5]   = Thermostat Night mode temperature
    - Settings.knx_CB_addr[6]   = Thermostat Nobody moving temperature
    - Settings.knx_CB_addr[7]   = Thermostat Vacancy temperature
        < 1000 = negative correction  : 900 = -10°C, 950 = -5°C
        > 1000 = absolute temperature : 1100 = 10°C, 1200 = 20°C

  How to enable Movement Detection :
    - connect a sensor like RCWM-0516
    - declare its GPIO as Switch 0

  How to enable Window Opened Detection :
    - enable option it in Configuration Pilotwire
    - if temperature drops of 0.5°C in less than 2mn, window is considered as opened, heater stops
    - if temperature increases of 0.2°C in less than 10mn, window is considered as closed again, heater restart

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifdef USE_PILOTWIRE

#define XSNS_99                         99

/*************************************************\
 *               Constants
\*************************************************/

#define D_PAGE_PILOTWIRE_CONFIG           "pw-cfg"
#define D_PAGE_PILOTWIRE_STATUS           "pw-status"
#define D_PAGE_PILOTWIRE_CONTROL          "control"
#define D_PAGE_PILOTWIRE_UPDATE           "control.upd"
#define D_PAGE_PILOTWIRE_GRAPH            "graph"
#define D_PAGE_PILOTWIRE_BASE_SVG         "graph-base.svg"
#define D_PAGE_PILOTWIRE_DATA_SVG         "graph-data.svg"

#define D_CMND_PILOTWIRE_PREFIX           "pw_"
#define D_CMND_PILOTWIRE_TYPE             "type"
#define D_CMND_PILOTWIRE_MODE             "mode"
#define D_CMND_PILOTWIRE_STATUS           "status"
#define D_CMND_PILOTWIRE_TARGET           "target"
#define D_CMND_PILOTWIRE_WINDOW           "window"
#define D_CMND_PILOTWIRE_MVT              "mvt"
#define D_CMND_PILOTWIRE_LOW              "low"
#define D_CMND_PILOTWIRE_HIGH             "high"
#define D_CMND_PILOTWIRE_NORMAL           "normal"
#define D_CMND_PILOTWIRE_NIGHT            "night"
#define D_CMND_PILOTWIRE_NOBODY           "nobody"
#define D_CMND_PILOTWIRE_VACANCY          "vacancy"

#define D_JSON_PILOTWIRE                  "Pilotwire"
#define D_JSON_PILOTWIRE_MODE             "Mode"
#define D_JSON_PILOTWIRE_STATUS           "Status"
#define D_JSON_PILOTWIRE_HEATING          "Heating"
#define D_JSON_PILOTWIRE_DETECT           "Detect"
#define D_JSON_PILOTWIRE_TARGET           "Target"
#define D_JSON_PILOTWIRE_TEMPERATURE      "Temperature"

#define D_PILOTWIRE                       "Pilotwire"
#define D_PILOTWIRE_CONFIGURE             "Configure"
#define D_PILOTWIRE_CONNEXION             "Connexion"
#define D_PILOTWIRE_MODE                  "Mode"
#define D_PILOTWIRE_OPTION                "Options"
#define D_PILOTWIRE_GRAPH                 "Graph"
#define D_PILOTWIRE_STATUS                "Status"
#define D_PILOTWIRE_NORMAL                "Normal"
#define D_PILOTWIRE_TARGET                "Target"
#define D_PILOTWIRE_CONTROL               "Control"
#define D_PILOTWIRE_TEMPERATURE           "Temp."
#define D_PILOTWIRE_DIRECT                "Direct"
#define D_PILOTWIRE_CHECKED               "checked"
#define D_PILOTWIRE_THERMOSTAT            "Thermostat"
#define D_PILOTWIRE_WINDOW                "Open Window Detection"
#define D_PILOTWIRE_MVT                   "Movement Detection"
#define D_PILOTWIRE_MOVEMENT              "Last movement"
#define D_PILOTWIRE_SOURCE_LOCAL          "Local"
#define D_PILOTWIRE_SOURCE_REMOTE         "Remote"
#define D_PILOTWIRE_SOURCE_UNDEFINED      "Undef."

// color codes
#define PILOTWIRE_COLOR_BACKGROUND        "#252525"       // page background
#define PILOTWIRE_COLOR_LOW               "#85c1e9"       // low temperature target
#define PILOTWIRE_COLOR_MEDIUM            "#ff9933"       // medium temperature target
#define PILOTWIRE_COLOR_HIGH              "#cc3300"       // high temperature target

// LittleFS environment
#ifdef USE_UFILESYS
#define D_PILOTWIRE_FILE_CFG            "/pilotwire.cfg"
#define D_PILOTWIRE_HISTO_FILE_WEEK     "/week-%d.csv"
#define D_PILOTWIRE_HISTO_WEEK          "week"
#endif    // USE_UFILESYS

// constant : temperature
#define PILOTWIRE_TEMP_THRESHOLD          0.25      // temperature threshold to switch on/off (°C)
#define PILOTWIRE_TEMP_STEP               0.5       // temperature selection step (°C)
#define PILOTWIRE_TEMP_UPDATE             5         // temperature update delay (s)
#define PILOTWIRE_TEMP_LIMIT_MIN          6         // minimum acceptable temperature
#define PILOTWIRE_TEMP_LIMIT_MAX          30        // maximum acceptable temperature
#define PILOTWIRE_TEMP_DEFAULT_LOW        10        // low range selectable temperature
#define PILOTWIRE_TEMP_DEFAULT_HIGH       25        // high range selectable temperature
#define PILOTWIRE_TEMP_DEFAULT_NORMAL     18        // default temperature
#define PILOTWIRE_TEMP_SCALE_LOW          18        // limit between economy and medium temperature scale
#define PILOTWIRE_TEMP_SCALE_HIGH         21        // limit between economy and medium temperature scale

// consant : movement detection
#define PILOTWIRE_MOVEMENT_TIMEOUT        30        // timeout after last movement detection (in sec.)
//#define PILOTWIRE_MOVEMENT_NOBODY_START   60        // if no mvt during 1h, nobody at home (in mn)
//#define PILOTWIRE_MOVEMENT_NOBODY_DROP    30        // delay between 0.5°C target drop in NOBODY mode (in mn)
//#define PILOTWIRE_MOVEMENT_VACANCY_START  2880      // if no mvt during 48h, home is vacant (in mn)
#define PILOTWIRE_MOVEMENT_NOBODY_START   2        // if no mvt during 1h, nobody at home (in mn)
#define PILOTWIRE_MOVEMENT_NOBODY_DROP    1        // delay between 0.5°C target drop in NOBODY mode (in mn)
#define PILOTWIRE_MOVEMENT_VACANCY_START  5      // if no mvt during 48h, home is vacant (in mn)

// constant : open window detection
#define PILOTWIRE_WINDOW_SAMPLE_NBR       24        // number of temperature samples to detect opened window (4mn for 1 sample every 10s)
#define PILOTWIRE_WINDOW_OPEN_PERIOD      10        // delay between 2 temperature samples in open window detection 
#define PILOTWIRE_WINDOW_OPEN_DROP        0.5       // temperature drop for window open detection (°C)
#define PILOTWIRE_WINDOW_CLOSE_INCREASE   0.2       // temperature increase to detect window closed (°C)  

// constant : graph
#define PILOTWIRE_GRAPH_SAMPLE            576       // number of graph points 
#define PILOTWIRE_GRAPH_WIDTH             576       // width of graph (pixels)
#define PILOTWIRE_GRAPH_HEIGHT            500       // height of graph (pixels)
#define PILOTWIRE_GRAPH_PERCENT_START     8         // percent of display before graph
#define PILOTWIRE_GRAPH_PERCENT_STOP      92        // percent of display after graph

// Historic data files
#define PILOTWIRE_HISTO_MIN_FREE          20        // minimum free size on filesystem (Kb)
#define PILOTWIRE_HISTO_WEEK_MAX          4         // number of weekly histotisation files

// constant chains
const char D_CONF_FIELDSET_START[] PROGMEM = "<fieldset><legend><b>&nbsp;%s&nbsp;</b></legend>\n";
const char D_CONF_FIELDSET_STOP[]  PROGMEM = "</fieldset><br />\n";
const char D_CONF_MODE_SELECT[]    PROGMEM = "<input type='radio' name='%s' id='%d' value='%d' %s>%s<br>\n";
const char D_GRAPH_SEPARATION[]    PROGMEM = "<line class='dash' x1='%d%%' y1='%d%%' x2='%d%%' y2='%d%%' />\n";
const char D_GRAPH_TEMPERATURE[]   PROGMEM = "<text class='temperature' x='%d%%' y='%d%%'>%s</text>\n";
const char D_CONF_FIELD_FULL[]     PROGMEM = "<p>%s<span class='key'>%s</span><br><input type='number' name='%s' min='%d' max='%d' step='%s' value='%s'></p>\n";

// device control
enum PilotwireDevices { PILOTWIRE_DEVICE_NORMAL, PILOTWIRE_DEVICE_DIRECT, PILOTWIRE_DEVICE_MAX };
const char kPilotwireDevice[] PROGMEM = "Pilotwire|Direct";                                                                // device type labels

// device modes
enum PilotwireConfigs  { PILOTWIRE_CONFIG_OFF, PILOTWIRE_CONFIG_ON, PILOTWIRE_CONFIG_THERM, PILOTWIRE_CONFIG_MAX };        // device configuration modes
const char kPilotwireConfig[] PROGMEM = "Forced OFF|Forced ON|Thermostat";                                               // device mode labels

// device temperature
enum PilotwireTemperature { PILOTWIRE_TEMP_LOW, PILOTWIRE_TEMP_HIGH, PILOTWIRE_TEMP_NORMAL, PILOTWIRE_TEMP_NIGHT, PILOTWIRE_TEMP_NOBODY, PILOTWIRE_TEMP_VACANCY, PILOTWIRE_TEMP_MAX };
const char kPilotwireTemperature[] PROGMEM = "Minimum|Maximum|Normal|Night|Absence|Vacancy";                               // temperature type labels

// device running status
enum PilotwireHeating { PILOTWIRE_HEATING_OFF, PILOTWIRE_HEATING_ON, PILOTWIRE_HEATING_OFFLOAD, PILOTWIRE_HEATING_WINDOW, PILOTWIRE_HEATING_MAX };
enum PilotwireStatus { PILOTWIRE_STATUS_OFF, PILOTWIRE_STATUS_ON, PILOTWIRE_STATUS_NORMAL, PILOTWIRE_STATUS_NIGHT, PILOTWIRE_STATUS_NOBODY, PILOTWIRE_STATUS_VACANCY, PILOTWIRE_STATUS_MAX };
const char kPilotwireStatus[] PROGMEM = "Forced OFF|Forced ON|Normal mode|Night mode|Absence mode|Vacancy mode";         // thermostat option labels

// graph periods
#ifdef USE_UFILESYS
  enum PilotwireGraphPeriod { PILOTWIRE_PERIOD_LIVE, PILOTWIRE_PERIOD_WEEK, PILOTWIRE_PERIOD_MAX };                 // available periods
  const char kPilotwireGraphPeriod[] PROGMEM = "Live|Week";                                                         // period labels
  const long ARR_PILOTWIRE_PERIOD_SAMPLE[] = { 3600 / PILOTWIRE_GRAPH_SAMPLE, 604800 / PILOTWIRE_GRAPH_SAMPLE };    // number of seconds between samples
#else
  enum PilotwireGraphPeriod { PILOTWIRE_PERIOD_LIVE, PILOTWIRE_PERIOD_MAX };                                        // available periods
  const char kPilotwireGraphPeriod[] PROGMEM = "Live";                                                              // period labels
  const long ARR_PILOTWIRE_PERIOD_SAMPLE[] = { 3600 / PILOTWIRE_GRAPH_SAMPLE };                                     // number of seconds between samples
#endif    // USE_UFILESYS

// pilotwire commands
const char kPilotwireCommand[] PROGMEM = D_CMND_PILOTWIRE_PREFIX "|" D_CMND_PILOTWIRE_TYPE "|" D_CMND_PILOTWIRE_MODE "|" D_CMND_PILOTWIRE_TARGET "|" D_CMND_PILOTWIRE_WINDOW "|" D_CMND_PILOTWIRE_MVT "|" D_CMND_PILOTWIRE_STATUS "|" D_CMND_PILOTWIRE_LOW "|" D_CMND_PILOTWIRE_HIGH "|" D_CMND_PILOTWIRE_NORMAL "|" D_CMND_PILOTWIRE_NIGHT "|" D_CMND_PILOTWIRE_NOBODY "|" D_CMND_PILOTWIRE_VACANCY;
void (* const PilotwireCommand[])(void) PROGMEM = { &CmndPilotwireType, &CmndPilotwireMode, &CmndPilotwireTarget, &CmndPilotwireWindow, &CmndPilotwireMvtDetect, &CmndPilotwireStatus, &CmndPilotwireLow, &CmndPilotwireHigh, &CmndPilotwireNormal, &CmndPilotwireNight, &CmndPilotwireNobody, &CmndPilotwireVacancy };

/****************************************\
 *               Icons
 * 
 *      xxd -i -c 256 icon.png
\****************************************/

// icon : none
#define PILOTWIRE_ICON_NONE       "none.png"      
unsigned char pilotwire_none_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0xd7, 0x07, 0x99, 0x4d, 0x00, 0x00, 0x00, 0x09, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x63, 0xe9, 0xc0, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x10, 0xe0, 0x00, 0x00, 0x10, 0xe0, 0x01, 0xd9, 0xa7, 0xc1, 0x74, 0x00, 0x00, 0x00, 0x12, 0x49, 0x44, 0x41, 0x54, 0x38, 0xcb, 0x63, 0x60, 0x18, 0x05, 0xa3, 0x60, 0x14, 0x8c, 0x02, 0xf2, 0x00, 0x00, 0x04, 0x40, 0x00, 0x01, 0x29, 0x8d, 0xe1, 0x55, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_none_len = 143;

// icon : heating (flame)
#define PILOTWIRE_ICON_FLAME "flame.png"      
unsigned char pilotwire_flame_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x80, 0x01, 0x03, 0x00, 0x00, 0x00, 0xce, 0x12, 0xfe, 0xf9, 0x00, 0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0xa1, 0x71, 0x55, 0xe0, 0x40, 0x06, 0xff, 0xbe, 0x77, 0xfb, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18, 0x00, 0x00, 0x01, 0x78, 0x49, 0x44, 0x41, 0x54, 0x38, 0xcb, 0x95, 0xd4, 0xbb, 0x71, 0xc4, 0x20, 0x10, 0x06, 0x60, 0x34, 0x04, 0x24, 0x9e, 0x51, 0xea, 0xc8, 0xb8, 0x10, 0x8f, 0x69, 0xc5, 0x25, 0xb8, 0x80, 0x9b, 0x01, 0x77, 0x46, 0x29, 0x2a, 0x81, 0x90, 0x00, 0x6b, 0x2d, 0x58, 0x1e, 0xbf, 0x5e, 0xf6, 0x58, 0xc1, 0x49, 0xdf, 0xdd, 0xb2, 0x62, 0xf7, 0x00, 0x21, 0x4e, 0x97, 0xf4, 0x88, 0x80, 0x88, 0x88, 0x04, 0x98, 0x56, 0xcc, 0x40, 0x0e, 0x81, 0xe9, 0x68, 0x01, 0x58, 0xcc, 0x6d, 0xe3, 0x2d, 0xf0, 0x45, 0x16, 0x5f, 0x64, 0x69, 0x07, 0x77, 0x03, 0xc2, 0x29, 0x10, 0x4e, 0x01, 0x31, 0x11, 0x85, 0x5b, 0xf4, 0xf9, 0xbc, 0xca, 0x01, 0x19, 0x36, 0xb4, 0xc9, 0xcd, 0x51, 0x0d, 0xe8, 0xb0, 0x61, 0xed, 0x65, 0xce, 0x03, 0xb4, 0x0c, 0x4c, 0xb4, 0xe8, 0x0e, 0x49, 0xde, 0x10, 0xd5, 0x82, 0x14, 0x62, 0x26, 0x67, 0x3b, 0x34, 0x39, 0xea, 0x30, 0xf4, 0x85, 0x90, 0x03, 0x96, 0xd4, 0x00, 0x91, 0x46, 0xd8, 0x8e, 0x89, 0xf8, 0x3a, 0x43, 0x5e, 0xe1, 0x09, 0xf1,
  0x82, 0xd0, 0xb7, 0x30, 0x0e, 0xe1, 0xef, 0x60, 0x17, 0x00, 0xed, 0x10, 0x8e, 0xc8, 0x13, 0x2d, 0x35, 0xc4, 0x0a, 0x83, 0x28, 0xa5, 0xa6, 0x8a, 0x19, 0x51, 0x3a, 0xb2, 0x72, 0x0f, 0xb8, 0x57, 0x0d, 0x53, 0xaf, 0x35, 0xdf, 0xce, 0x70, 0x42, 0xba, 0x1c, 0x6d, 0x19, 0xca, 0x67, 0x3c, 0x1a, 0xec, 0x86, 0xcf, 0x0c, 0x5f, 0xf1, 0xc1, 0x98, 0x0b, 0x04, 0x17, 0x34, 0x2f, 0x07, 0xa4, 0x06, 0x3d, 0x10, 0x0e, 0x08, 0x07, 0x44, 0x46, 0x14, 0x66, 0x87, 0x48, 0x80, 0xef, 0xd2, 0x24, 0xae, 0xdb, 0xd0, 0x1d, 0x2c, 0x77, 0xf9, 0x04, 0xae, 0xd1, 0x8b, 0x72, 0xbb, 0x80, 0x3b, 0xc2, 0x34, 0x6c, 0xfd, 0x7a, 0x2f, 0xa8, 0xdd, 0x7b, 0x33, 0xad, 0x7d, 0x1b, 0x9e, 0x1b, 0x56, 0x5e, 0xa9, 0x00, 0x7d, 0x85, 0x74, 0x0d, 0xfb, 0x1b, 0xe2, 0xff, 0xb0, 0xee, 0x61, 0xae, 0x60, 0x2a, 0x52, 0x45, 0xca, 0x3f, 0xff, 0x81, 0x92, 0xb5, 0xed, 0xf1, 0x1d, 0xca, 0xff, 0xa3, 0xc6, 0xda, 0x0a, 0x65, 0x59, 0x3b, 0x5e, 0x9c, 0x4b, 0x81, 0xe7, 0xa5, 0xbe, 0xd4, 0xaf, 0x4a, 0xb4, 0xaf, 0xc1, 0x39, 0x4f, 0x8e, 0xe6, 0xb5, 0xae, 0x39, 0x8f, 0x2d, 0xb9, 0xf9, 0xb3, 0xf4, 0xd5, 0xcb, 0xda, 0xb1, 0x1c, 0x10, 0x6d, 0xdd, 0x18, 0x33, 0xee, 0x1f, 0x85, 0xdb, 0xac, 0xed, 0x7a, 0x3e, 0x22, 0x09, 0xb7, 0xbd, 0xe1, 0xe7, 0x24, 0x5a, 0xfb, 0xa8, 0x1d, 0x7d, 0x0a, 0x86, 0xb4, 0x0c, 0x42, 0x8c, 0x41, 0xed, 0x80, 0x54, 0x23, 0x8a, 0x93, 0x8f, 0x93, 0x5c, 0xd5, 0x11, 0x3f, 0xf8, 0xb0, 0x16, 0x77, 0x62, 0xac, 0x21, 0x76, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_flame_len = 498;

// icon : opened window
#define PILOTWIRE_ICON_WINDOW "window.png"      
unsigned char pilotwire_window_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0xe3, 0xe6, 0xe2, 0xea, 0xed, 0xe9, 0xf1, 0xf4, 0xf1, 0xfd, 0xff, 0xfc, 0x6a, 0xf4, 0xb4, 0x19, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x2e, 0x23, 0x00, 0x00, 0x2e, 0x23, 0x01, 0x78, 0xa5, 0x3f, 0x76, 0x00, 0x00, 0x01, 0x5e, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0x99, 0x5d, 0x92, 0x82, 0x30, 0x10, 0x84, 0x43, 0xb9, 0x07, 0xa0, 0x88, 0x07, 0x70, 0x77, 0x3d, 0x80, 0x62, 0x0e, 0x60, 0x91, 0xb9, 0xff, 0x99, 0x24, 0x68, 0x20, 0x3f, 0x40, 0x66, 0xe0, 0x49, 0xaa, 0xfb, 0x45, 0xad, 0x62, 0xbe, 0x19, 0x9b, 0x90, 0xa2, 0xd2, 0x4a, 0x1d, 0x41, 0xcd, 0xef, 0xbe, 0xca, 0x13, 0x91, 0xbd, 0x6c, 0x29, 0xaf, 0x0c, 0xd1, 0xad, 0xff, 0xbc, 0x52, 0xaf, 0xbb, 0xbc, 0x5e, 0xbb, 0x3a, 0xdb, 0x7f, 0xa1, 0x41, 0xb6, 0x96, 0xb7, 0x77, 0x1a, 0x01, 0xc2, 0x21, 0xb4, 0xaf, 0x0a, 0x00, 0x82, 0x21, 0x7c, 0xfb, 0x04, 0x40, 0xd4, 0x0a, 0xdb, 0x67, 0x00, 0xd6, 0x10, 0x41, 0xfb, 0x1c, 0xc0, 0x70, 0x42, 0xc7, 0xd7, 0x67, 0x00, 0xb2, 0x7f, 0xab, 0x32, 0x54, 0x02, 0xf0, 0x65, 0x03, 0xc0, 0xa5, 0x91, 0xd7, 0xdf, 0xab, 0x10, 0x90, 0x58, 0xc3, 0x68, 0x5f, 0xab, 0x18, 0xd0, 0x3f, 0x19, 0x92, 0x7a, 0xf7, 0x14, 0xa5,
  0x00, 0x55, 0x5d, 0xb9, 0xe5, 0xdd, 0x70, 0xb7, 0x33, 0x40, 0x76, 0x8b, 0x16, 0xff, 0xfd, 0x67, 0x41, 0xe4, 0x00, 0x96, 0x13, 0xe3, 0x62, 0x9b, 0x03, 0xa8, 0xb3, 0xfb, 0x65, 0x16, 0xe5, 0x9f, 0xe0, 0x75, 0xc0, 0x73, 0x79, 0x19, 0xfe, 0x1c, 0x03, 0xd0, 0xc1, 0x03, 0x78, 0x00, 0x0f, 0xe0, 0x01, 0x3c, 0x80, 0x07, 0xf0, 0xa0, 0xec, 0x41, 0xbd, 0x77, 0x82, 0x48, 0x05, 0x40, 0xf9, 0x4d, 0x15, 0x80, 0x6f, 0x05, 0x3c, 0xbc, 0x0c, 0x03, 0x30, 0x5e, 0x1c, 0x00, 0x6e, 0xd8, 0x0f, 0xb0, 0x27, 0xc2, 0x03, 0x78, 0x00, 0x0f, 0xe0, 0x01, 0x3c, 0x80, 0x07, 0xf0, 0x00, 0x1e, 0xc0, 0x83, 0x32, 0xc0, 0x2e, 0x9f, 0x29, 0x9b, 0x22, 0x80, 0x71, 0x3a, 0xbe, 0x06, 0xe0, 0x1d, 0xf1, 0xfb, 0xa3, 0xed, 0x1c, 0xf0, 0xcf, 0x8e, 0x16, 0x66, 0x01, 0x92, 0x84, 0x61, 0x18, 0x22, 0x01, 0x68, 0x12, 0xa9, 0x4d, 0x00, 0xd2, 0x80, 0xc3, 0x0d, 0x11, 0x02, 0x1e, 0x7b, 0x43, 0x9a, 0xed, 0xca, 0x00, 0xa5, 0xac, 0x2b, 0xcd, 0x51, 0x52, 0x00, 0x23, 0xfc, 0x6c, 0x56, 0x00, 0x1d, 0x2b, 0xef, 0x8b, 0x86, 0x88, 0x00, 0xec, 0xc4, 0xb1, 0x99, 0x05, 0x74, 0x82, 0xcc, 0x73, 0x1a, 0x62, 0x02, 0x08, 0x53, 0x57, 0x3d, 0x01, 0x8c, 0xb4, 0x7d, 0x38, 0x84, 0xfd, 0x6c, 0x12, 0x1b, 0x42, 0xdf, 0xf7, 0x10, 0xc3, 0xe6, 0xa3, 0xe5, 0xed, 0xfd, 0x10, 0xad, 0x3a, 0x82, 0x5e, 0x79, 0x0c, 0xf1, 0xa9, 0x4d, 0xea, 0xcf, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_window_len = 481;

#define PILOTWIRE_ICON_MOVE "move.png"      
unsigned char pilotwire_move_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x01, 0x03, 0x00, 0x00, 0x00, 0xf9, 0xf0, 0xf3, 0x88, 0x00, 0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0x19, 0xe3, 0x55, 0xfd, 0x96, 0x53, 0x7a, 0x7c, 0x65, 0x52, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18, 0x00, 0x00, 0x01, 0x9a, 0x49, 0x44, 0x41, 0x54, 0x48, 0xc7, 0xed, 0xd5, 0xb1, 0x6e, 0x83, 0x30, 0x10, 0x06, 0xe0, 0x43, 0xae, 0x42, 0x87, 0x2a, 0xac, 0x1d, 0x22, 0xe5, 0x15, 0x3a, 0x66, 0xe3, 0x55, 0xf2, 0x08, 0x8c, 0x9d, 0x8a, 0xfb, 0x64, 0xa5, 0xea, 0x8b, 0xb0, 0x75, 0x2c, 0x23, 0x03, 0xf2, 0xf5, 0xbf, 0xf3, 0x19, 0x30, 0x89, 0x14, 0x75, 0xe9, 0xd2, 0x5a, 0x02, 0xc1, 0x17, 0xb0, 0xef, 0x7c, 0x87, 0x42, 0xf4, 0x3f, 0xfe, 0xf2, 0xd8, 0xad, 0x6f, 0x1a, 0x1c, 0xfb, 0x35, 0x3c, 0xe3, 0x38, 0xc4, 0xcb, 0xc2, 0xcb, 0xf9, 0xb4, 0x40, 0x35, 0x92, 0xdd, 0x9c, 0x22, 0x1c, 0x27, 0x39, 0x3f, 0xd8, 0x6b, 0x18, 0x75, 0x20, 0x9b, 0xb0, 0xa1, 0x27, 0xb9, 0x6c, 0x99, 0xe8, 0x8e, 0x4a, 0x5c, 0xf5, 0xba, 0x16, 0x31, 0xcb, 0xef, 0x11, 0x86, 0x08, 0x1e, 0xb7, 0xce, 0x53, 0xd1, 0x81, 0x0c, 0x9c, 0x57, 0x00, 0x21, 0x0c, 0x01, 0x5c, 0xcb, 0xc9, 0xf9, 0x08, 0x5d, 0xfc, 0x51, 0x1f, 0xb3, 0x27, 0xa8, 0x57, 0x28, 0x29, 0xcd, 0x81, 0xd9, 0xfa, 0x1c, 0x1a, 0x01,
  0xcb, 0x5f, 0xe2, 0x50, 0x28, 0x2d, 0x7f, 0x89, 0x14, 0x31, 0x9f, 0x17, 0x08, 0x9a, 0xa8, 0x00, 0x32, 0x74, 0xcc, 0x3c, 0x29, 0x34, 0x0b, 0x48, 0x02, 0x8f, 0x80, 0x9d, 0x6c, 0x4a, 0x09, 0xe8, 0xd7, 0x50, 0x5d, 0x83, 0xec, 0x95, 0x23, 0x60, 0x5c, 0x43, 0x6d, 0xab, 0xcc, 0xd0, 0x02, 0xc2, 0x16, 0x78, 0x0d, 0x3c, 0xb4, 0x9a, 0x5c, 0x82, 0x82, 0xfb, 0x05, 0x24, 0xd2, 0x82, 0xbb, 0x56, 0x76, 0x6c, 0x06, 0xc7, 0x3e, 0x46, 0x16, 0x73, 0xd9, 0x03, 0x0a, 0x56, 0x39, 0x59, 0xfa, 0x2e, 0x28, 0x0c, 0xd8, 0x8f, 0xb8, 0x63, 0x2e, 0x48, 0xba, 0x88, 0xb5, 0xb1, 0x3d, 0x2d, 0x26, 0xc0, 0x1b, 0x62, 0x4d, 0x40, 0x23, 0xf2, 0x3f, 0x02, 0xce, 0x94, 0xea, 0x52, 0x71, 0xa8, 0x00, 0x52, 0x97, 0x58, 0x39, 0x40, 0xc9, 0xa3, 0x56, 0x2e, 0xd6, 0x16, 0xcf, 0x3b, 0x1e, 0xb4, 0xb6, 0x64, 0x30, 0x12, 0xf7, 0xf1, 0xf5, 0x9e, 0x0c, 0xa4, 0x13, 0x05, 0xce, 0xda, 0x72, 0xba, 0x83, 0xa4, 0x1d, 0xa4, 0x0d, 0x55, 0x1b, 0xec, 0x52, 0x5b, 0x26, 0xd8, 0x2f, 0xa0, 0x7d, 0xab, 0x8d, 0x7b, 0xd8, 0xc2, 0x7d, 0xac, 0xbd, 0x36, 0x32, 0x76, 0xc8, 0x46, 0x02, 0x5a, 0x20, 0xdc, 0x80, 0x58, 0x96, 0x1b, 0xe0, 0x73, 0xf8, 0xca, 0x00, 0x55, 0xfa, 0x94, 0x3a, 0xa5, 0x21, 0x35, 0xc8, 0x40, 0x6a, 0xf0, 0xa1, 0x2d, 0x65, 0xa3, 0xbc, 0x06, 0xef, 0x96, 0xff, 0x0c, 0xaf, 0x96, 0xee, 0x0c, 0xfe, 0x12, 0xa6, 0x0d, 0xb4, 0x53, 0xbe, 0x6c, 0xfc, 0x1a, 0x56, 0x81, 0xd9, 0xa7, 0xbe, 0xca, 0xb5, 0xde, 0xa4, 0x8b, 0x52, 0x6d, 0xa0, 0xba, 0x84, 0x7c, 0x43, 0xb0, 0xf6, 0x05, 0x74, 0x39, 0xb8, 0x9f, 0x43, 0xb1, 0x9d, 0x94, 0xb6, 0x71, 0xd0, 0xcb, 0xff, 0xdf, 0xc2, 0xaf, 0x8d, 0x6f,
  0xb1, 0x9b, 0x2c, 0x00, 0x2f, 0x10, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_move_len = 532;

// icon : forced OFF (nofrost)
#define PILOTWIRE_ICON_OFF "nofrost.png"      
unsigned char pilotwire_off_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x16, 0x8f, 0xe5, 0x22, 0x93, 0xea, 0x25, 0x95, 0xec, 0x1e, 0x9a, 0xef, 0x4c, 0xac, 0x99, 0xf5, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2, 0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x03, 0x13, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0x59, 0x6d, 0x92, 0x23, 0x21, 0x08, 0x35, 0x38, 0x07, 0x98, 0xdd, 0x13, 0x18, 0xc9, 0x01, 0xba, 0xe8, 0x39, 0xc0, 0x54, 0xed, 0xfd, 0xef, 0xb4, 0x93, 0xa4, 0x3f, 0x00, 0x51, 0xda, 0x36, 0x35, 0xb5, 0x55, 0x3b, 0xfe, 0xea, 0x44, 0x7c, 0x3e, 0x11, 0x01, 0x31, 0x84, 0x7f, 0xbc, 0xe1, 0x9c, 0x86, 0xc6, 0x43, 0xce, 0x79, 0x08, 0xe0, 0x6b, 0x7c, 0x4e, 0xa3, 0x00, 0xef, 0x23, 0x00, 0xbf, 0x47, 0x01, 0xfe, 0x67, 0x06, 0x88, 0x49, 0x31, 0xe8, 0xdb, 0xce, 0xcd, 0x7e, 0x36, 0x06, 0x9d, 0x16, 0xb5, 0xd9, 0xcf, 0x06, 0xd0, 0x69, 0x51, 0x77, 0xf1, 0xcc, 0x01, 0xe0, 0x0c, 0x40, 0x62, 0x00, 0xf9, 0x0c, 0x40, 0xde, 0x01, 0xa0, 0x17, 0x20, 0xae, 0x03, 0x16, 0x80, 0x0d, 0xb0, 0x9b, 0xc2, 0x13, 0xa0, 0x83, 0x00, 0x2c, 0xf3, 0xac, 0x43, 0x9e, 0x00, 0x9c, 0xc0, 0xc5, 0x9d, 0x39, 0x71, 0x0a, 0x0f, 0x00, 0x4e, 0x00, 0xda, 0x2b, 0x01, 0x2e,
  0x78, 0xff, 0x7e, 0x00, 0x70, 0x02, 0xce, 0x52, 0xee, 0xca, 0xbb, 0x71, 0x2d, 0xec, 0x8d, 0xe1, 0x7a, 0xda, 0x0f, 0x8c, 0xc2, 0xde, 0x42, 0x2f, 0x40, 0xb0, 0x08, 0xb8, 0x00, 0xa0, 0x65, 0x15, 0x81, 0xe0, 0xda, 0x03, 0xdf, 0x6f, 0x83, 0x40, 0x20, 0xcf, 0x1e, 0xb8, 0x30, 0x94, 0x04, 0xfc, 0x43, 0x49, 0x5a, 0x5a, 0x12, 0xf0, 0x0f, 0xa5, 0x50, 0x12, 0x14, 0x04, 0xc0, 0x3d, 0x12, 0x51, 0x48, 0x68, 0x02, 0x2d, 0x80, 0x79, 0x32, 0x38, 0x2e, 0x14, 0x50, 0x20, 0x2e, 0xbf, 0x50, 0xae, 0x24, 0x13, 0x3b, 0x03, 0x49, 0x51, 0x98, 0x0c, 0x1d, 0x6b, 0x5d, 0x6c, 0x3d, 0x72, 0xa3, 0x41, 0x12, 0xa8, 0x89, 0x71, 0x8f, 0xa3, 0x7a, 0x24, 0x21, 0x10, 0x52, 0xc8, 0x75, 0x47, 0x2b, 0x82, 0x52, 0x93, 0x0c, 0x2c, 0x6b, 0x27, 0x16, 0x1e, 0x2a, 0x6e, 0xea, 0x8e, 0x72, 0x4e, 0x09, 0xb0, 0xcc, 0xab, 0x37, 0x57, 0x6c, 0x18, 0x78, 0x00, 0x39, 0x64, 0x0b, 0x80, 0xac, 0xa3, 0x67, 0x03, 0x18, 0x52, 0x65, 0xdf, 0x11, 0x80, 0xd9, 0xf4, 0xc3, 0x4d, 0x00, 0xb0, 0x65, 0xac, 0x55, 0xf8, 0x00, 0x58, 0x8d, 0x05, 0x8f, 0xf6, 0x69, 0x02, 0x30, 0x01, 0x6a, 0x44, 0x13, 0xa1, 0x9f, 0x0a, 0x00, 0x36, 0xe3, 0x11, 0x5f, 0x83, 0x0d, 0x40, 0x4e, 0x44, 0x63, 0x08, 0x1c, 0xa0, 0xaa, 0xff, 0xe2, 0x4c, 0x30, 0x84, 0x1d, 0x00, 0x1a, 0xfa, 0x0f, 0xe6, 0x3e, 0x95, 0x29, 0x8e, 0x8b, 0x50, 0x86, 0x12, 0x90, 0x1f, 0x15, 0x23, 0x0c, 0x76, 0x28, 0xfa, 0x1a, 0x08, 0xfa, 0xa3, 0x45, 0x22, 0x77, 0xb6, 0xe4, 0x4d, 0x6f, 0x35, 0xac, 0x93, 0x90, 0x3d, 0xb5, 0xf1, 0x29, 0x62, 0x85, 0x03, 0x27, 0x30, 0xed, 0x2e, 0x47, 0xb5, 0x47, 0x0f, 0x99, 0x14, 0xa2, 0x36, 0xb2, 0xfa, 0xaa, 0xc1,
  0xb4, 0xe7, 0x48, 0x9a, 0x56, 0x43, 0x6b, 0x16, 0x00, 0x94, 0xa4, 0xf4, 0xfa, 0x59, 0xce, 0x7e, 0x79, 0xfe, 0x33, 0x6b, 0x25, 0xde, 0x5a, 0x3e, 0x4a, 0xf6, 0x61, 0xf1, 0x17, 0x95, 0xb6, 0x71, 0xe1, 0xe3, 0xaf, 0xa5, 0xd5, 0xe1, 0x24, 0xe7, 0x2b, 0xac, 0xb3, 0x09, 0x60, 0x0d, 0x68, 0x02, 0xfc, 0x3a, 0x71, 0x69, 0x71, 0x18, 0x74, 0x02, 0xfc, 0x30, 0xf8, 0x16, 0x06, 0xd7, 0xd4, 0xc9, 0x20, 0x97, 0x0e, 0xad, 0xd3, 0x94, 0x73, 0x11, 0x59, 0x55, 0xe2, 0x76, 0x15, 0x0c, 0x92, 0x7d, 0x2d, 0x3c, 0x7e, 0x9c, 0xb9, 0x38, 0x34, 0x3c, 0xd2, 0x34, 0xe8, 0x50, 0xf8, 0xd5, 0xa8, 0x68, 0x9f, 0xad, 0x10, 0xa7, 0x66, 0x22, 0xd3, 0xa9, 0x6a, 0xe4, 0xba, 0x5b, 0xc7, 0x8a, 0x5f, 0x0f, 0x6f, 0x55, 0x27, 0x15, 0x73, 0x77, 0xd3, 0x49, 0x06, 0x76, 0x0e, 0x9f, 0x5f, 0x1e, 0x5c, 0x9f, 0x39, 0xff, 0x48, 0x78, 0xd7, 0x9a, 0x38, 0x91, 0x60, 0x70, 0xb1, 0x9b, 0x4e, 0x71, 0xa2, 0x9b, 0xa2, 0x99, 0x46, 0xc2, 0x92, 0x2c, 0x70, 0x17, 0xc0, 0xac, 0x01, 0xad, 0x34, 0x0f, 0xc8, 0x41, 0x80, 0xe3, 0x89, 0xa6, 0x9d, 0x23, 0xcd, 0x95, 0x83, 0xf3, 0x5e, 0xb1, 0xf7, 0x56, 0x92, 0xe4, 0x27, 0xdb, 0xa9, 0x6d, 0x46, 0x07, 0xd2, 0xfd, 0xd4, 0x4c, 0xd2, 0x6c, 0x80, 0x98, 0x0f, 0x24, 0x59, 0xe4, 0x5e, 0x79, 0xec, 0xbd, 0xd8, 0x00, 0xde, 0xce, 0x5d, 0xba, 0xb6, 0x1c, 0x29, 0x1c, 0xb8, 0xb5, 0xad, 0xee, 0x06, 0xcb, 0x43, 0xf0, 0x71, 0xf0, 0xe2, 0x59, 0x73, 0xaa, 0x24, 0xef, 0xe7, 0x8d, 0xab, 0x2f, 0x15, 0x67, 0x62, 0xf3, 0xc8, 0x54, 0x5e, 0xbe, 0xb3, 0x51, 0xa3, 0x29, 0x00, 0x28, 0x9b, 0xd7, 0x7f, 0xca, 0x65, 0x39, 0x20, 0xad, 0x3d, 0x32, 0xc9, 0xfa, 0x33, 0x29,
  0x2a, 0x66, 0x04, 0x61, 0xfc, 0x66, 0x72, 0x0b, 0x49, 0xbb, 0x77, 0x3f, 0x52, 0x02, 0x79, 0x55, 0x11, 0x06, 0x46, 0xcb, 0x40, 0x7c, 0xbe, 0x5a, 0x21, 0x6a, 0xf2, 0x0a, 0x51, 0xc3, 0xa5, 0xb0, 0xa9, 0x71, 0xc0, 0xe9, 0x48, 0x35, 0x6f, 0x1a, 0x28, 0x07, 0x0e, 0x17, 0x24, 0xa1, 0x9e, 0x21, 0xa4, 0xfd, 0xd8, 0x7a, 0x3a, 0x68, 0x16, 0x65, 0xc9, 0xad, 0xe6, 0x2d, 0xf7, 0x88, 0x5a, 0x59, 0xd8, 0x2d, 0x50, 0x63, 0x72, 0x0a, 0xd3, 0x07, 0x2b, 0xec, 0xa7, 0x4b, 0xe3, 0xba, 0xb6, 0x76, 0xb6, 0x38, 0x4f, 0xa3, 0xcf, 0x03, 0xf4, 0x92, 0x07, 0x8a, 0xd1, 0x27, 0x92, 0xa1, 0x47, 0x9a, 0x38, 0xfa, 0x4c, 0x14, 0x70, 0xb1, 0xa7, 0x3d, 0x2e, 0x20, 0x9e, 0x7a, 0x77, 0x1c, 0x7e, 0xac, 0xfb, 0x01, 0x78, 0xc1, 0x83, 0xe5, 0xf0, 0xb3, 0xf1, 0xf0, 0xc3, 0xf5, 0xf0, 0xd3, 0xf9, 0x77, 0xb4, 0xbf, 0x79, 0x22, 0x6f, 0xd1, 0x98, 0x8e, 0xe2, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_off_len = 918;

// icon : forced ON (comfort)
#define PILOTWIRE_ICON_FORCED "forced.png"      
unsigned char pilotwire_forced_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0xe7, 0x9e, 0x19, 0xf0, 0xa4, 0x0e, 0xf6, 0xa2, 0x13, 0xfb, 0xa1, 0x15, 0x23, 0xc7, 0x17, 0xda, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2, 0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x05, 0x65, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xdd, 0x59, 0xeb, 0x99, 0xdb, 0x38, 0x0c, 0xb4, 0x97, 0x2a, 0x60, 0xf7, 0xb3, 0x0b, 0x48, 0x09, 0xda, 0x03, 0x0a, 0x90, 0x03, 0xf4, 0x5f, 0xd3, 0x11, 0x0f, 0x52, 0xa4, 0x4c, 0xca, 0x92, 0xf8, 0xeb, 0x4e, 0x1b, 0x67, 0x13, 0x5b, 0x22, 0xc1, 0x01, 0x30, 0x18, 0xc0, 0xb7, 0xdb, 0xff, 0xfd, 0x9a, 0x98, 0xf9, 0x7b, 0xe4, 0x79, 0x64, 0x46, 0x1e, 0x58, 0x80, 0x08, 0x80, 0x60, 0xb9, 0xfc, 0xfc, 0x9d, 0x58, 0x2e, 0x1a, 0x3a, 0x41, 0x7c, 0x9e, 0x86, 0x20, 0x44, 0xa2, 0xeb, 0x20, 0x4c, 0x10, 0x21, 0x88, 0x56, 0x0c, 0x59, 0x40, 0x4c, 0x38, 0x84, 0x41, 0x3c, 0xc1, 0x10, 0x06, 0xc8, 0x43, 0x47, 0x00, 0x90, 0x33, 0xf0, 0x98, 0x05, 0x04, 0x38, 0xb2, 0x80, 0x38, 0xe1, 0xba, 0x05, 0xc1, 0x20, 0x18, 0xb0, 0xc0, 0x20, 0x38, 0x6c, 0xc1, 0x9d, 0x79, 0xde, 0x1c, 0x41, 0x21, 0xd8, 0x58, 0x70, 0xff, 0xe9, 0x2d, 0x20, 0x61, 0xbb, 0x59, 0x40, 0x21,
  0xa8, 0xdf, 0x0c, 0x5d, 0xbf, 0x06, 0x06, 0xe2, 0x65, 0x73, 0xef, 0x3b, 0x21, 0x20, 0x12, 0xb6, 0x13, 0x1c, 0x65, 0x37, 0xdc, 0x7a, 0x41, 0xfe, 0xd4, 0xdb, 0xf4, 0xb2, 0x23, 0xc6, 0x2d, 0x31, 0x56, 0x8b, 0x4f, 0x0a, 0x41, 0xbd, 0x68, 0xc4, 0x95, 0xa1, 0x69, 0x82, 0xf8, 0x8c, 0xea, 0xed, 0x82, 0x41, 0x50, 0xbd, 0xc5, 0x4f, 0xe6, 0xb6, 0x67, 0x59, 0x20, 0xe0, 0x0a, 0x85, 0x60, 0x10, 0x60, 0x6d, 0xc0, 0x4b, 0xde, 0x9b, 0xdf, 0x17, 0x00, 0x24, 0xbd, 0x1b, 0x2b, 0x2f, 0x6c, 0x72, 0x21, 0xc8, 0x2d, 0x62, 0xd5, 0x77, 0xcb, 0x82, 0xf8, 0x21, 0x56, 0x8b, 0x07, 0x54, 0x08, 0xa0, 0xd8, 0x45, 0x0e, 0x29, 0x5b, 0x75, 0x2c, 0x30, 0x23, 0x0a, 0x56, 0xe6, 0xfa, 0x50, 0x62, 0x80, 0x70, 0x5c, 0xf3, 0x08, 0x53, 0xf4, 0xaf, 0x80, 0x56, 0x3a, 0xe2, 0x29, 0xeb, 0xc1, 0x5c, 0x1a, 0xc0, 0x76, 0xd0, 0xd6, 0x02, 0x66, 0x1d, 0x56, 0x67, 0x86, 0xc8, 0x48, 0xcb, 0x36, 0xb9, 0xe2, 0xa1, 0x9a, 0x24, 0x45, 0x1a, 0x07, 0xd1, 0x19, 0xdc, 0xab, 0x24, 0xe6, 0x67, 0x59, 0x62, 0xe9, 0xd6, 0x31, 0xd4, 0xbf, 0x3a, 0xb1, 0x4e, 0x0e, 0x41, 0x2f, 0x19, 0xc4, 0x7a, 0x22, 0xf1, 0xe4, 0xdc, 0xf9, 0x5c, 0x21, 0xa0, 0xa6, 0x0f, 0x1c, 0xe3, 0xf8, 0xa9, 0xdc, 0xd4, 0x3e, 0x83, 0x78, 0xc9, 0x20, 0xe8, 0xd6, 0x52, 0x8d, 0x85, 0xde, 0x11, 0x6f, 0x4a, 0xf1, 0x04, 0xdc, 0xc5, 0x48, 0x58, 0x58, 0x1d, 0xd1, 0x31, 0x11, 0x7c, 0xf9, 0x1d, 0x86, 0x62, 0x0b, 0xc7, 0x4e, 0xbe, 0xb3, 0x15, 0x2a, 0x98, 0x77, 0x58, 0x54, 0x20, 0x88, 0x58, 0xb6, 0x45, 0x09, 0x10, 0x7d, 0x30, 0xc0, 0x4d, 0xc8, 0xf9, 0x7b, 0x87, 0x2a, 0x71, 0x82, 0x41, 0xb0, 0xab, 0x37, 0x82, 0x6e, 0x32, 0xa7,
  0x40, 0x46, 0x8f, 0xad, 0x2a, 0x15, 0xf7, 0x99, 0x59, 0x4a, 0x09, 0x66, 0x8a, 0xa3, 0x58, 0xdd, 0x0b, 0x56, 0x04, 0x81, 0x60, 0xfe, 0x58, 0x4b, 0x3c, 0x0a, 0xbc, 0x2a, 0x89, 0xdb, 0x63, 0x74, 0x7b, 0x7a, 0xe3, 0xe7, 0x2a, 0x33, 0xb9, 0x0b, 0x84, 0xbd, 0x29, 0x71, 0x04, 0x79, 0xec, 0x4c, 0x84, 0xf3, 0xe1, 0xaa, 0xa6, 0xec, 0xe4, 0xb8, 0x33, 0xf3, 0xd1, 0x07, 0x73, 0x50, 0x6a, 0x5a, 0xc5, 0xa0, 0x32, 0x9a, 0x39, 0x2d, 0x12, 0x92, 0x36, 0xd1, 0xf4, 0x13, 0x14, 0x7a, 0xf9, 0xd1, 0x77, 0x06, 0x3a, 0xbf, 0xd9, 0xf6, 0x31, 0x86, 0x4e, 0x09, 0x9d, 0x90, 0x0d, 0x37, 0xa1, 0xa8, 0x01, 0x70, 0x06, 0x05, 0x7f, 0x38, 0xf2, 0x21, 0x6b, 0x0e, 0x23, 0x9d, 0x54, 0x3a, 0x6c, 0x16, 0x28, 0xb9, 0x90, 0x46, 0x02, 0x9d, 0x92, 0xed, 0x41, 0xb7, 0x2f, 0x20, 0x50, 0xc1, 0x8a, 0xf3, 0x09, 0x1f, 0x38, 0x04, 0x64, 0xb9, 0x95, 0xb8, 0xf4, 0xf8, 0x09, 0xc0, 0x21, 0xd0, 0x07, 0xc5, 0x9d, 0x62, 0xce, 0x09, 0xad, 0xc4, 0xbc, 0x85, 0xc0, 0xb8, 0x6e, 0x1e, 0x83, 0xa0, 0x47, 0x54, 0xad, 0x3c, 0x20, 0xca, 0x10, 0x50, 0x86, 0x80, 0xf8, 0xb7, 0xa7, 0xce, 0x1e, 0x3f, 0x8f, 0x9f, 0x9f, 0x47, 0x7c, 0x79, 0x14, 0x80, 0x57, 0x40, 0xf5, 0x7e, 0x86, 0xa0, 0xdb, 0x3d, 0x05, 0xca, 0x37, 0xf2, 0x5a, 0xe3, 0x14, 0x02, 0xc8, 0x10, 0x60, 0x41, 0x46, 0x9c, 0x2e, 0xda, 0xfc, 0x9f, 0xbd, 0xe8, 0x16, 0xe1, 0x9b, 0x20, 0x60, 0xcd, 0x4e, 0x5c, 0x35, 0x02, 0xe9, 0x87, 0xba, 0x42, 0x80, 0x75, 0x45, 0x7e, 0x79, 0x09, 0xd3, 0x1a, 0x5b, 0x43, 0x20, 0x96, 0xcc, 0xc6, 0x59, 0x10, 0x7f, 0x62, 0x3f, 0xe7, 0x55, 0x7e, 0x92, 0x7f, 0x82, 0x5e, 0xd1, 0x70, 0x2f, 0x20, 0x1e, 0x41,
  0x25, 0x04, 0xe8, 0x06, 0x4e, 0x85, 0xc1, 0xca, 0xd0, 0xc1, 0x6e, 0x5a, 0x3b, 0xbc, 0x7b, 0x09, 0x01, 0xad, 0x10, 0xa0, 0x11, 0x2a, 0xe0, 0x6a, 0xb0, 0x32, 0x5d, 0xb0, 0xfb, 0x51, 0xaf, 0xb4, 0x40, 0x86, 0x80, 0x33, 0x04, 0xec, 0x74, 0x8b, 0x2b, 0x04, 0x8c, 0x2f, 0x3d, 0x42, 0x5e, 0xc0, 0x3a, 0xbc, 0x49, 0x03, 0x39, 0x43, 0x80, 0x2b, 0x04, 0x8a, 0x01, 0x09, 0x04, 0x64, 0x10, 0xb0, 0x5b, 0xa0, 0xb7, 0x69, 0x61, 0x07, 0x3b, 0x24, 0x24, 0x08, 0x14, 0x43, 0xf5, 0x65, 0x96, 0x2e, 0x9c, 0xcf, 0x1b, 0x57, 0xf8, 0xc7, 0x2c, 0xb0, 0x05, 0x52, 0x51, 0x0b, 0x60, 0xcd, 0x5e, 0x15, 0x05, 0xfa, 0xd2, 0xb2, 0xba, 0x3a, 0x4d, 0x2a, 0x8f, 0x89, 0x2b, 0xf6, 0x30, 0x32, 0x93, 0xee, 0x84, 0x1d, 0x08, 0xd4, 0x02, 0x70, 0x00, 0x35, 0xd5, 0x7e, 0x5d, 0x97, 0x68, 0xea, 0xe4, 0x16, 0x51, 0x1e, 0x6c, 0x42, 0xa0, 0x9c, 0x14, 0xdb, 0xf9, 0x88, 0x00, 0x9a, 0xac, 0x24, 0x5f, 0x00, 0x15, 0x83, 0xf8, 0x7b, 0x49, 0x0b, 0xb4, 0x20, 0x20, 0x0f, 0xa4, 0xe4, 0xf2, 0xc4, 0xf5, 0x16, 0x41, 0x6a, 0xb2, 0x55, 0x72, 0xac, 0x21, 0xa0, 0xcc, 0x2e, 0x38, 0x27, 0x8b, 0x13, 0x06, 0xf3, 0x2d, 0x9b, 0xa0, 0xdb, 0x2e, 0x49, 0x8d, 0x51, 0x01, 0x81, 0xa9, 0x9e, 0xb5, 0x8d, 0x8f, 0x4e, 0xb4, 0xb8, 0x25, 0xfa, 0x7b, 0xeb, 0x69, 0x21, 0x5c, 0x21, 0xc8, 0x25, 0x3a, 0x65, 0x5f, 0xf0, 0x7a, 0x81, 0x08, 0x3b, 0x72, 0x2f, 0x41, 0xe0, 0x02, 0x5c, 0x45, 0xc2, 0xe1, 0xe2, 0x34, 0xa9, 0xea, 0x06, 0x7f, 0x32, 0x69, 0xf8, 0xbe, 0xbe, 0x6c, 0xf4, 0x8f, 0x24, 0xb1, 0x98, 0xc1, 0xd6, 0xd0, 0x16, 0x08, 0x96, 0xe3, 0x85, 0x29, 0xa7, 0x5b, 0x09, 0x01, 0x1e, 0x2e, 0x4d, 0x98, 0x20,
  0x10, 0x75, 0x43, 0x26, 0xc1, 0x4f, 0xf5, 0xd0, 0x13, 0x38, 0x04, 0x9c, 0xa3, 0x54, 0x0e, 0xf4, 0x3a, 0xd1, 0xb5, 0x8f, 0x41, 0xe0, 0xaa, 0x5b, 0x9e, 0xac, 0x20, 0x38, 0xa3, 0x70, 0x8c, 0x0e, 0x6b, 0x08, 0x4e, 0xc9, 0xac, 0x15, 0x02, 0xcc, 0x10, 0x9c, 0x12, 0x49, 0x53, 0x82, 0x80, 0x33, 0x04, 0x70, 0x4e, 0xa6, 0xe1, 0x1b, 0x04, 0x27, 0x67, 0x7a, 0x61, 0x0b, 0xc1, 0x61, 0x91, 0x06, 0x9e, 0x62, 0x50, 0x43, 0x00, 0xc7, 0x77, 0xf6, 0xac, 0xff, 0xaa, 0x20, 0x70, 0x17, 0xe0, 0x67, 0xa5, 0x25, 0xc4, 0x9a, 0xd4, 0xb6, 0xb6, 0xde, 0xd6, 0xa8, 0xce, 0xae, 0x9d, 0xf0, 0x53, 0x4a, 0x4f, 0x5a, 0x12, 0x8a, 0x21, 0x10, 0x6a, 0x59, 0x5e, 0x12, 0xb2, 0xd1, 0x9e, 0x3f, 0x1f, 0x34, 0x76, 0x62, 0x6f, 0x49, 0x6b, 0x34, 0x62, 0x4b, 0x3d, 0x4f, 0xe4, 0x09, 0xfe, 0x20, 0x79, 0x8d, 0x8b, 0x56, 0x25, 0x72, 0x97, 0x69, 0xdc, 0x77, 0xd9, 0xf6, 0x7d, 0x10, 0xfe, 0xcc, 0x4f, 0xa1, 0x61, 0xf8, 0xee, 0x29, 0x70, 0x71, 0x09, 0xec, 0x1b, 0xa0, 0x64, 0xba, 0x74, 0xa3, 0x13, 0x9f, 0x7b, 0x6a, 0x4f, 0x4e, 0x58, 0xb6, 0x6d, 0x6f, 0x2c, 0x01, 0x1a, 0x14, 0xd0, 0xef, 0xf9, 0x4c, 0x25, 0x74, 0x9c, 0x3d, 0x19, 0xbf, 0xbe, 0xfa, 0x28, 0xb8, 0xd2, 0x88, 0x65, 0xa3, 0xcd, 0xb5, 0x98, 0x40, 0xa0, 0xfe, 0x7c, 0xc1, 0xa3, 0xb7, 0xdb, 0xd6, 0xaa, 0x8d, 0x3d, 0x7e, 0xb7, 0x6a, 0x97, 0xa4, 0x53, 0xe3, 0x7a, 0xd8, 0xf6, 0xbd, 0x61, 0xf9, 0x24, 0xf5, 0x50, 0x60, 0x2a, 0x43, 0x25, 0xde, 0xbc, 0x52, 0xe9, 0x97, 0x96, 0x4c, 0x92, 0xe2, 0x3e, 0x37, 0x27, 0xf9, 0xa9, 0x4f, 0x5a, 0x0d, 0xd8, 0x10, 0x01, 0xda, 0x90, 0x24, 0xbe, 0x7e, 0x7b, 0x8d, 0xbb, 0x9e, 0xb2, 0x9a,
  0x64, 0x41, 0x31, 0x8b, 0x13, 0x94, 0xc0, 0xa8, 0xaa, 0xf5, 0x55, 0x80, 0x35, 0xea, 0x5c, 0x7c, 0x9d, 0x60, 0x9a, 0xb2, 0x68, 0xb7, 0xb5, 0x0b, 0x23, 0x6c, 0x36, 0x2f, 0x77, 0x4e, 0x10, 0xd4, 0x33, 0x8f, 0x8a, 0x4d, 0xef, 0x46, 0x11, 0xd4, 0xa4, 0xf8, 0x24, 0x17, 0x0b, 0x17, 0x58, 0xab, 0x52, 0x36, 0xfc, 0x4f, 0xad, 0x54, 0x08, 0xdc, 0x2d, 0x26, 0xd5, 0xda, 0x06, 0x41, 0xe9, 0xf5, 0x2f, 0xc0, 0xed, 0xcc, 0xb0, 0x9c, 0x01, 0xe3, 0xa6, 0x39, 0x7c, 0x58, 0xa3, 0xb2, 0xbc, 0xb7, 0xa4, 0x4b, 0x7b, 0x28, 0x2b, 0x12, 0x76, 0x1b, 0x7a, 0xc4, 0xf5, 0x97, 0x34, 0xe6, 0xc8, 0xb9, 0x9b, 0x2c, 0x7f, 0x36, 0xc5, 0xe1, 0xed, 0x6e, 0xcd, 0x36, 0xea, 0x17, 0x93, 0xb7, 0xe1, 0xda, 0x96, 0x82, 0x64, 0x46, 0xd2, 0x9b, 0xa3, 0x7c, 0x6d, 0xf9, 0x0e, 0x2c, 0xb2, 0x97, 0xb7, 0x91, 0xff, 0xf1, 0xfa, 0x46, 0x8d, 0xfd, 0xc2, 0xef, 0x99, 0x02, 0x29, 0x81, 0x7b, 0xfd, 0x9b, 0x2e, 0xb8, 0x36, 0x7f, 0x29, 0x23, 0x51, 0x87, 0x5f, 0xd7, 0x2d, 0xf0, 0x41, 0xf1, 0x80, 0x05, 0xbc, 0x33, 0xdf, 0x3c, 0x08, 0xe2, 0x81, 0xe9, 0xd9, 0x1e, 0x88, 0xa4, 0x2a, 0x63, 0xc4, 0x0b, 0xc8, 0x63, 0x47, 0xd0, 0x4e, 0x70, 0x00, 0x44, 0xeb, 0xff, 0x06, 0x16, 0x98, 0xac, 0xdf, 0xbb, 0x7e, 0x84, 0xa0, 0xc5, 0x0c, 0xaf, 0x2f, 0x70, 0xa3, 0x3c, 0x65, 0xb8, 0x6a, 0x02, 0xe1, 0x08, 0x04, 0xff, 0x91, 0xeb, 0x5f, 0x90, 0x21, 0x89, 0xdd, 0x00, 0x8d, 0x9b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_forced_len = 1512;

// icon : normal mode (thermostat)
#define PILOTWIRE_ICON_NORMAL "normal.png"      
unsigned char pilotwire_normal_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0xf8, 0xfb, 0xf8, 0xfa, 0xfc, 0xf9, 0xfb, 0xfd, 0xfa, 0xff, 0xff, 0xff, 0xd8, 0x98, 0xc9, 0xce, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18, 0x00, 0x00, 0x01, 0x20, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0xd9, 0x41, 0x0e, 0x84, 0x20, 0x0c, 0x05, 0xd0, 0x26, 0xbd, 0x50, 0x93, 0xde, 0xff, 0x6e, 0x63, 0x04, 0x44, 0xc4, 0xc5, 0xb4, 0xdf, 0xd1, 0x8c, 0xf9, 0xac, 0x66, 0x16, 0x7d, 0xb6, 0x82, 0xd8, 0x88, 0xc8, 0x6f, 0x87, 0x2f, 0x03, 0x8d, 0x47, 0x04, 0x75, 0x4c, 0x68, 0xf1, 0x6e, 0x00, 0x00, 0xdd, 0x86, 0x1a, 0xa9, 0xd9, 0x14, 0xb6, 0x40, 0x00, 0x38, 0xfc, 0x08, 0x57, 0x60, 0x17, 0x01, 0x92, 0x06, 0xe4, 0x3a, 0xc0, 0x1e, 0x06, 0x94, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x78, 0x0d, 0xa0, 0x8e, 0x01, 0xa5, 0xcf, 0x02, 0x00, 0x07, 0x01, 0x2d, 0x5d, 0xe2, 0xd3, 0x80, 0x13, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x78, 0x11, 0xa0, 0x7b, 0xc0, 0x53, 0xf1, 0x7b, 0xc0, 0x12, 0x05, 0xac, 0x2d, 0x6a, 0x03, 0x3c, 0x95, 0xc0, 0xf6, 0x55, 0x37, 0x91, 0x42, 0x8b, 0xab, 0x42, 0x3c, 0x85, 0x5e, 0x40, 0xab, 0xc5, 0xc2, 0x53,
  0x20, 0xee, 0x5d, 0x88, 0xa6, 0x30, 0x24, 0x90, 0x99, 0xc9, 0x7a, 0xd1, 0x21, 0x05, 0x4b, 0x2d, 0x22, 0x00, 0xf0, 0x61, 0x04, 0x6b, 0x38, 0x56, 0xb0, 0xfc, 0x0f, 0x03, 0x7a, 0x00, 0x24, 0x08, 0xc8, 0x09, 0x60, 0x08, 0xe0, 0x61, 0xc0, 0x7d, 0xba, 0x8b, 0x06, 0x4c, 0xc2, 0xfd, 0x80, 0xfd, 0x7f, 0x09, 0x20, 0x70, 0xba, 0x0e, 0xf4, 0xee, 0x85, 0x84, 0x3e, 0x0b, 0xd3, 0xd3, 0x18, 0x03, 0xe6, 0x85, 0x10, 0xdc, 0x0f, 0xa6, 0x1d, 0x09, 0x06, 0xa2, 0x5b, 0xda, 0x74, 0x13, 0x24, 0x0e, 0x0c, 0x29, 0x58, 0x78, 0x5b, 0xd7, 0x31, 0x85, 0xc4, 0x49, 0xd1, 0x1a, 0x00, 0xbc, 0xda, 0xca, 0xdb, 0x5d, 0xb6, 0x03, 0xcf, 0xf8, 0xcb, 0xb5, 0xb6, 0x04, 0xf5, 0xca, 0x99, 0x63, 0xd3, 0xfd, 0x49, 0x69, 0xa6, 0xc1, 0x28, 0x73, 0xd0, 0xad, 0x44, 0x97, 0xa5, 0xbd, 0xb7, 0x48, 0x1e, 0xdb, 0x8e, 0x0b, 0x09, 0x13, 0x44, 0x30, 0x41, 0xf2, 0x03, 0x3d, 0xbc, 0xff, 0x62, 0x7c, 0x00, 0x1b, 0x6c, 0xf5, 0x9e, 0x7f, 0xb0, 0x52, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_normal_len = 419;

// icon : night mode (thermostat)
#define PILOTWIRE_ICON_NIGHT "night.png"      
unsigned char pilotwire_night_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x28, 0x54, 0x6a, 0x96, 0x8d, 0x72, 0xfc, 0xd3, 0x7b, 0xdc, 0xe1, 0xe3, 0xbf, 0x19, 0x5c, 0x64, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0d, 0xd7, 0x00, 0x00, 0x0d, 0xd7, 0x01, 0x42, 0x28, 0x9b, 0x78, 0x00, 0x00, 0x03, 0x1a, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xc5, 0x9a, 0x6d, 0x92, 0xa4, 0x20, 0x0c, 0x86, 0x9b, 0x1b, 0x18, 0xf4, 0x02, 0xa0, 0x17, 0x10, 0xfa, 0x02, 0xa8, 0xf7, 0x3f, 0xd3, 0x56, 0xb7, 0x1f, 0xcd, 0x47, 0x12, 0xd0, 0xec, 0xd6, 0xe6, 0xc7, 0x54, 0x4d, 0x8f, 0x3c, 0xbc, 0x49, 0x90, 0x86, 0x64, 0x5e, 0x2f, 0xc6, 0xe0, 0xb0, 0xd7, 0x23, 0x83, 0xc4, 0x84, 0xc3, 0x6f, 0x23, 0x14, 0x20, 0xd6, 0x49, 0xa6, 0xbf, 0x27, 0x02, 0x40, 0x46, 0x00, 0x90, 0x11, 0x00, 0x64, 0x04, 0x00, 0x19, 0x01, 0x40, 0x46, 0x50, 0x75, 0x40, 0x27, 0x1c, 0xcf, 0x13, 0xa0, 0xc9, 0x84, 0x02, 0x18, 0x09, 0x8d, 0xe3, 0x69, 0x02, 0x34, 0x9b, 0x50, 0x00, 0x25, 0x01, 0x40, 0x26, 0x41, 0xdd, 0x01, 0x74, 0x42, 0x01, 0x98, 0x04, 0x75, 0x0f, 0xd0, 0x09, 0x05, 0x94, 0x12, 0xd4, 0x5d, 0x40, 0xd7, 0x24, 0xc0, 0xda, 0x66, 0x09, 0xe7, 0xc7, 0xcb, 0xef, 0x09, 0x3d, 0x7a, 0x6f, 0xd2, 0x41, 0x81, 0x04, 0x9c, 0x1e,
  0x0c, 0xdb, 0x6f, 0x76, 0xef, 0x7d, 0x2e, 0x20, 0x90, 0x3e, 0x40, 0x0e, 0xf8, 0x4c, 0xef, 0x1d, 0x30, 0x00, 0xc0, 0x43, 0x78, 0x3c, 0xa2, 0xfd, 0xc7, 0x0c, 0x0b, 0xe8, 0x98, 0x1c, 0x7c, 0xe7, 0xf7, 0x73, 0x3e, 0x5e, 0x93, 0x80, 0xfc, 0xc9, 0x11, 0x17, 0x30, 0x04, 0x22, 0x0f, 0x0a, 0x1d, 0x5f, 0x08, 0x00, 0xbd, 0x10, 0x4b, 0xe1, 0x0b, 0x18, 0xae, 0xbf, 0xee, 0x01, 0x28, 0x05, 0x44, 0x8f, 0x64, 0x80, 0xef, 0xaf, 0xd3, 0x95, 0xc1, 0x7d, 0xbc, 0x2b, 0xd7, 0x4e, 0x94, 0xe4, 0xd4, 0x87, 0xd4, 0xc1, 0x91, 0x12, 0x40, 0x02, 0x14, 0x92, 0x01, 0xef, 0xa1, 0x0e, 0xe8, 0x50, 0xc0, 0x48, 0x7a, 0xa0, 0xb7, 0xcd, 0xa2, 0x80, 0xf4, 0xb1, 0x7d, 0x7c, 0x9e, 0x03, 0xbb, 0x5d, 0x36, 0x15, 0x3e, 0x24, 0x4f, 0xf6, 0x1e, 0x0d, 0x41, 0x98, 0x2e, 0xc0, 0x12, 0x32, 0x80, 0xc2, 0x04, 0xa0, 0x21, 0x98, 0xb6, 0x80, 0x05, 0x21, 0x01, 0x1c, 0x6b, 0x00, 0x0b, 0x41, 0x19, 0xc4, 0x03, 0x80, 0x85, 0x10, 0x59, 0x86, 0x18, 0x00, 0x4a, 0x80, 0xf7, 0xe4, 0x2a, 0x68, 0x02, 0xf4, 0x0f, 0x00, 0x0a, 0xf3, 0xc0, 0xa3, 0xdb, 0x60, 0xf6, 0x36, 0x1e, 0x41, 0x50, 0x98, 0x07, 0x38, 0x40, 0x57, 0x01, 0x67, 0x0e, 0xf0, 0x24, 0x10, 0x0a, 0xd0, 0x10, 0xe0, 0x00, 0x08, 0xd8, 0xe6, 0x8e, 0x86, 0x40, 0x0c, 0x98, 0x59, 0xc0, 0x10, 0x08, 0xc0, 0x15, 0x02, 0x0a, 0x70, 0x24, 0x77, 0x5b, 0x22, 0x80, 0xba, 0x03, 0x28, 0x83, 0xd9, 0x25, 0x80, 0xbe, 0x11, 0x00, 0x46, 0x0a, 0x00, 0x02, 0x30, 0x4a, 0x01, 0xd7, 0x78, 0x2a, 0x8d, 0xff, 0x04, 0x00, 0x32, 0x00, 0xe0, 0xcb, 0x40, 0x0e, 0xf0, 0xff, 0x07, 0xd0, 0x47, 0x00, 0xf3, 0x04, 0x30, 0x48, 0x01, 0xb1, 0x82, 0x99, 0xda, 0x42,
  0x5a, 0x63, 0xe0, 0x8a, 0xf7, 0xee, 0xa6, 0x02, 0xff, 0x44, 0x41, 0x1c, 0x03, 0x2e, 0x08, 0xba, 0x49, 0x01, 0xf3, 0x3a, 0xf5, 0x2d, 0x31, 0xe0, 0xd6, 0xa2, 0x6d, 0x02, 0xd0, 0x3e, 0x68, 0x27, 0x04, 0xf4, 0x24, 0x00, 0x7c, 0x93, 0x0f, 0xbe, 0x11, 0x40, 0x49, 0xd0, 0x7b, 0x7c, 0xa7, 0x23, 0xc1, 0xc4, 0x86, 0xc2, 0x48, 0x18, 0x77, 0xc0, 0xb1, 0xc4, 0xd2, 0x1d, 0x69, 0x6d, 0x90, 0xa0, 0x8f, 0xcf, 0x8f, 0x25, 0x46, 0x6d, 0xaa, 0xb4, 0x84, 0xec, 0x1a, 0x43, 0x6d, 0xeb, 0xa4, 0x84, 0x3e, 0xdb, 0x2b, 0x78, 0x80, 0xc7, 0x1c, 0xe0, 0x00, 0x3a, 0x07, 0x38, 0xec, 0x22, 0xe1, 0xb2, 0x03, 0x02, 0x9d, 0xc7, 0x92, 0x50, 0x5e, 0x64, 0xa8, 0xaf, 0xf7, 0xcb, 0x6c, 0xe5, 0x22, 0x43, 0x9d, 0x50, 0x22, 0x0d, 0x26, 0x3f, 0xc6, 0x73, 0x00, 0xed, 0x11, 0xb3, 0xdf, 0x11, 0xda, 0xa2, 0x5e, 0xa1, 0x87, 0xac, 0xb5, 0x50, 0xe1, 0x1c, 0x11, 0x96, 0xe2, 0x98, 0xb7, 0xfa, 0xaa, 0x19, 0x16, 0xd0, 0x3f, 0x00, 0xd4, 0x83, 0xc0, 0x24, 0x96, 0x3e, 0xad, 0x93, 0x36, 0x57, 0x00, 0x55, 0x1f, 0x90, 0xd3, 0xba, 0xba, 0xe3, 0x83, 0xab, 0xdd, 0x58, 0x6a, 0x3e, 0x18, 0xec, 0xda, 0x06, 0xed, 0x12, 0x1c, 0x7a, 0xf3, 0x44, 0x5e, 0x98, 0xb5, 0x29, 0x84, 0x50, 0x5e, 0x3c, 0x07, 0x3e, 0x8c, 0xef, 0xea, 0xcd, 0x75, 0xe0, 0x57, 0xe3, 0x4c, 0x94, 0x82, 0x52, 0x80, 0x6e, 0x8d, 0x00, 0x20, 0x05, 0x8c, 0xe9, 0x8a, 0xc2, 0x3b, 0x57, 0x8f, 0xec, 0x91, 0x48, 0x05, 0x63, 0xc3, 0x37, 0xa6, 0xdd, 0x02, 0x59, 0xcc, 0xca, 0x01, 0xfa, 0x37, 0x29, 0xb7, 0xc5, 0x76, 0x48, 0x11, 0x66, 0xa3, 0x17, 0xf4, 0x9b, 0x2b, 0x86, 0xa9, 0x0c, 0x70, 0x12, 0xd6, 0xe8, 0xa7, 0xe1, 0xca, 0x71,
  0x27, 0xc0, 0x6c, 0xc1, 0xfc, 0x0a, 0x61, 0xc9, 0xfc, 0x86, 0xaf, 0xe7, 0xed, 0x55, 0x98, 0xb8, 0x3e, 0xa0, 0xd7, 0x38, 0x0e, 0xce, 0x54, 0xca, 0x79, 0xbb, 0x84, 0x25, 0xae, 0x4f, 0xe8, 0xdf, 0x6b, 0xf5, 0xb6, 0xf5, 0x82, 0x62, 0x16, 0x83, 0x1d, 0x61, 0x3f, 0xf3, 0xbf, 0x9d, 0xbd, 0x51, 0x4f, 0xdc, 0x1e, 0xd7, 0x44, 0x55, 0x03, 0x60, 0x30, 0x5c, 0x55, 0xb6, 0x01, 0x90, 0x9c, 0x7b, 0x89, 0xb2, 0xf0, 0xc4, 0x02, 0x02, 0x5b, 0x99, 0xbe, 0xde, 0xc6, 0xa7, 0xb5, 0x71, 0x75, 0x07, 0xd0, 0x51, 0xc5, 0x79, 0x2d, 0xe9, 0x0f, 0x88, 0xdb, 0x03, 0xe2, 0x06, 0x85, 0xbc, 0x45, 0x22, 0x6e, 0xd2, 0xc8, 0xdb, 0x44, 0xf2, 0x46, 0x95, 0xb8, 0x55, 0x26, 0x6f, 0xd6, 0xc9, 0xdb, 0x85, 0xf2, 0x86, 0xa5, 0xbc, 0x65, 0x2a, 0x6f, 0xda, 0xca, 0xdb, 0xc6, 0xf2, 0xc6, 0xb5, 0xbc, 0x75, 0xfe, 0x17, 0x9a, 0xf7, 0xcd, 0xff, 0x3e, 0xf0, 0x07, 0xe6, 0xb9, 0x65, 0xac, 0xaf, 0x8f, 0x94, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_night_len = 925;

// icon : nobody mode (thermostat)
#define PILOTWIRE_ICON_NOBODY "nobody.png"      
unsigned char pilotwire_nobody_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0xe9, 0xec, 0xe8, 0xef, 0xf2, 0xee, 0xf1, 0xf4, 0xf0, 0xf3, 0xf6, 0xf2, 0xdb, 0xbd, 0x10, 0x52, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2, 0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x05, 0x85, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0x59, 0x59, 0x76, 0xea, 0x30, 0x0c, 0x4d, 0x1b, 0x2f, 0x00, 0x4a, 0x17, 0xf0, 0x0a, 0x2c, 0xc0, 0x44, 0x5e, 0x40, 0xc0, 0xde, 0xff, 0x9a, 0x9e, 0xad, 0xc1, 0x53, 0x9c, 0x38, 0x29, 0xbf, 0xcd, 0xe9, 0xe1, 0xb4, 0x34, 0x11, 0xf2, 0xd5, 0xd5, 0xd5, 0xc0, 0x30, 0xfc, 0x5d, 0xad, 0x4b, 0xcd, 0x6f, 0x3e, 0x6f, 0xec, 0x7b, 0x16, 0x6e, 0xce, 0x98, 0x77, 0x9e, 0x1f, 0x8d, 0x05, 0xf7, 0x8e, 0x0b, 0xc6, 0x81, 0x03, 0xa0, 0xc3, 0x38, 0xf7, 0xef, 0xb8, 0x03, 0xce, 0x3b, 0x00, 0x06, 0x5d, 0x00, 0x6f, 0xec, 0xb0, 0x01, 0xc0, 0xe7, 0x2d, 0x3e, 0x78, 0x31, 0x70, 0xd8, 0x40, 0x70, 0xdf, 0x9b, 0xf0, 0x3f, 0xfe, 0x8f, 0x6f, 0x6f, 0xea, 0xe0, 0xf3, 0x9f, 0xde, 0x80, 0x7f, 0x3a, 0x98, 0xf0, 0x87, 0xf8, 0xf6, 0xae, 0x1c, 0x76, 0x00, 0x9f, 0x46, 0x2f, 0x3c, 0x9e, 0x60, 0xa6, 0x83, 0x08, 0x92, 0xfb, 0xf4, 0x32, 0x07, 0x10, 0x0f, 0x1a, 0xf0,
  0x2e, 0x7b, 0xfc, 0x66, 0xcf, 0x45, 0xf0, 0x9f, 0x3e, 0x5c, 0xdc, 0x41, 0x10, 0x03, 0x87, 0xbc, 0x89, 0x61, 0x70, 0xd6, 0x07, 0xd0, 0xe8, 0xc3, 0x20, 0x92, 0xfb, 0xc9, 0x95, 0x80, 0xc5, 0xa1, 0xe7, 0x05, 0x7d, 0xcf, 0x41, 0x74, 0xc5, 0x47, 0x64, 0x3a, 0x84, 0xa0, 0x4b, 0xd4, 0xc3, 0x33, 0xc0, 0x31, 0x03, 0x48, 0x41, 0xd0, 0x92, 0xd3, 0x90, 0x25, 0xc5, 0x5e, 0x07, 0x2c, 0x53, 0x38, 0x5c, 0x8e, 0xd8, 0x60, 0x8e, 0x21, 0x40, 0x52, 0x32, 0x06, 0x2f, 0x14, 0x72, 0xf2, 0x00, 0x13, 0x47, 0x44, 0x4d, 0x23, 0x9d, 0xd1, 0x8c, 0x41, 0x4c, 0x77, 0x63, 0x30, 0x5a, 0x24, 0x0f, 0x2a, 0x92, 0x84, 0x12, 0x13, 0x5b, 0xef, 0x3e, 0x80, 0x08, 0x51, 0x70, 0x05, 0xf0, 0x17, 0x44, 0x75, 0x27, 0x08, 0x0a, 0x79, 0x33, 0x31, 0x87, 0x80, 0x82, 0x49, 0xca, 0x30, 0xef, 0x74, 0x20, 0xdc, 0xab, 0x39, 0x18, 0x40, 0x2e, 0x28, 0x34, 0x65, 0xf6, 0x39, 0x80, 0x1c, 0x48, 0x74, 0x24, 0x0a, 0x53, 0x28, 0xf5, 0x2e, 0x0e, 0x19, 0x09, 0x21, 0xfe, 0x86, 0xb9, 0x48, 0xa1, 0xdc, 0xa5, 0x6a, 0x0a, 0x89, 0x8b, 0x5e, 0x07, 0xfe, 0x51, 0x16, 0xd0, 0x79, 0xe4, 0xb7, 0xed, 0xe7, 0xe9, 0x19, 0x76, 0x05, 0xe1, 0xb4, 0x98, 0xd5, 0x92, 0x9f, 0x3d, 0x1c, 0x6f, 0xe8, 0xf4, 0x2c, 0xc1, 0x30, 0x16, 0x39, 0x19, 0x43, 0x69, 0x0d, 0xf4, 0x1d, 0x00, 0x41, 0x0d, 0x73, 0x88, 0x5f, 0x28, 0x2b, 0x6d, 0x37, 0x94, 0x98, 0xc4, 0xc2, 0xa1, 0xdc, 0x04, 0x87, 0xd2, 0x74, 0x52, 0x2a, 0x68, 0x07, 0xd0, 0x2d, 0x24, 0x01, 0xc4, 0x24, 0x09, 0x25, 0x15, 0x89, 0x2d, 0x1c, 0x51, 0xff, 0x10, 0x41, 0x45, 0x12, 0x60, 0x44, 0xd7, 0x11, 0xc7, 0x91, 0x64, 0x3e, 0x7b, 0xe0, 0xc3, 0xc1, 0x69, 0xc1,
  0xa1, 0x59, 0xb0, 0xc8, 0xce, 0xe0, 0x3d, 0xd3, 0x31, 0xb2, 0xba, 0x10, 0xae, 0xbc, 0x7a, 0x27, 0xba, 0xba, 0x12, 0x81, 0x10, 0xd9, 0x89, 0x70, 0x2c, 0xea, 0x83, 0x0d, 0x2e, 0x9b, 0x52, 0xc8, 0x08, 0x2e, 0xf1, 0x5c, 0xc8, 0x1c, 0x00, 0xd1, 0x22, 0xb0, 0x90, 0xaa, 0xb7, 0x8b, 0xd5, 0x3b, 0x49, 0x29, 0x61, 0x41, 0xd0, 0xc5, 0xe2, 0x88, 0x80, 0x48, 0x28, 0xe7, 0x54, 0x3b, 0x10, 0x67, 0x5d, 0x9c, 0x21, 0x66, 0x3f, 0x38, 0x52, 0x66, 0x3e, 0x0d, 0xeb, 0xc9, 0x98, 0x83, 0x78, 0xa7, 0xfb, 0xa6, 0xa2, 0x1e, 0x46, 0x2c, 0xd0, 0x04, 0x7d, 0x04, 0x8b, 0x32, 0x72, 0xc8, 0x65, 0x64, 0x96, 0xfb, 0x72, 0x26, 0x4b, 0x5f, 0x61, 0x8b, 0x17, 0xd2, 0x44, 0x3a, 0xde, 0xad, 0xa0, 0x9d, 0x6d, 0xc8, 0xbd, 0xaa, 0x9e, 0x26, 0x04, 0x6c, 0x75, 0xda, 0x24, 0x58, 0xe6, 0x55, 0xb3, 0xc9, 0xc5, 0x1c, 0xe2, 0x74, 0x36, 0x31, 0x18, 0xcd, 0x0e, 0xc2, 0xd6, 0xbd, 0x25, 0x70, 0x12, 0x13, 0x13, 0x09, 0x01, 0xf6, 0xa7, 0xcc, 0xa4, 0x1b, 0x99, 0xad, 0xe4, 0x5e, 0x92, 0xd8, 0xff, 0x0b, 0xae, 0x30, 0xdd, 0xa6, 0x2b, 0x3b, 0x80, 0x84, 0x2a, 0x3f, 0x8b, 0xa0, 0xd1, 0x75, 0x73, 0x6b, 0xe4, 0xf0, 0xa5, 0xab, 0xe8, 0x19, 0x94, 0x06, 0x1a, 0xe5, 0xc2, 0xba, 0xa8, 0x84, 0x36, 0x73, 0x55, 0x9c, 0x7a, 0x56, 0xc9, 0x17, 0xde, 0x6b, 0x28, 0x02, 0x41, 0xf7, 0x4a, 0x84, 0x89, 0x4e, 0x3d, 0xeb, 0xf4, 0xb7, 0x75, 0x68, 0x38, 0x89, 0xc3, 0x41, 0xa6, 0xbc, 0x54, 0x71, 0x5e, 0x3d, 0xca, 0xbb, 0x3f, 0x8c, 0x3b, 0xb5, 0x3a, 0x03, 0x96, 0xc3, 0xf8, 0x9e, 0x04, 0xc3, 0xec, 0x68, 0x73, 0x6c, 0x96, 0xc4, 0x11, 0x83, 0x14, 0xd9, 0x7e, 0x61, 0x70, 0x99, 0x8a, 0x44, 0x0c, 0x22,
  0xb5, 0xcc, 0xb3, 0x6f, 0xc0, 0xc6, 0x1c, 0x8a, 0x18, 0xdc, 0x93, 0x53, 0x8f, 0x7d, 0xdd, 0x11, 0x25, 0x71, 0x34, 0x60, 0x92, 0x38, 0x15, 0x1e, 0xa8, 0xe9, 0xfc, 0xf5, 0xf3, 0xdd, 0x6c, 0xaf, 0x4c, 0x51, 0x08, 0x41, 0xb2, 0xa9, 0xca, 0x3c, 0x22, 0x47, 0xa5, 0xf3, 0x36, 0xc9, 0x21, 0x64, 0x20, 0x02, 0x6b, 0x8c, 0xad, 0x34, 0xd8, 0x2e, 0xe6, 0x10, 0x9b, 0xc9, 0x61, 0x1a, 0xbd, 0xa2, 0x53, 0xf9, 0x11, 0xd0, 0x2c, 0x8b, 0x65, 0x05, 0x22, 0xbd, 0xbc, 0x96, 0x20, 0xe6, 0x18, 0x28, 0xc7, 0x52, 0x61, 0x16, 0x18, 0x88, 0xa0, 0xa5, 0x8f, 0x8a, 0xf2, 0xf2, 0x58, 0x38, 0x50, 0x9f, 0x21, 0xca, 0x61, 0x86, 0x01, 0x24, 0x71, 0x7a, 0x2d, 0x1c, 0x30, 0x50, 0xaa, 0x84, 0x4d, 0x5a, 0x06, 0x39, 0x06, 0xdc, 0xad, 0x4e, 0x99, 0x03, 0x86, 0xc5, 0xd2, 0xcc, 0x35, 0x88, 0xac, 0x84, 0x25, 0x88, 0xd4, 0xad, 0x3e, 0xab, 0x4e, 0xa4, 0xec, 0x89, 0x19, 0x44, 0xe9, 0x2b, 0xb2, 0x74, 0x8e, 0xf2, 0xfc, 0xa8, 0x43, 0x80, 0x26, 0xe6, 0x12, 0x03, 0x69, 0x6c, 0xb2, 0x74, 0x8e, 0xf2, 0xfc, 0xac, 0x43, 0x80, 0x76, 0x74, 0x61, 0xc0, 0xc6, 0x71, 0x2d, 0x67, 0x22, 0xa5, 0x78, 0x7c, 0x8f, 0x2b, 0x8e, 0xf0, 0xab, 0x21, 0xd5, 0xb0, 0x48, 0x67, 0x13, 0x9b, 0x07, 0xac, 0x70, 0x14, 0x2a, 0x0e, 0xda, 0x9c, 0x77, 0xda, 0x10, 0xf1, 0xad, 0xe4, 0x3b, 0x8b, 0x18, 0xea, 0xf1, 0x89, 0xa6, 0x82, 0xe0, 0x5e, 0xd6, 0xb6, 0x50, 0x9f, 0x58, 0xce, 0x48, 0xf7, 0x54, 0xa0, 0x74, 0xd2, 0x63, 0xed, 0xa3, 0xc3, 0x5a, 0xe5, 0x5f, 0xd2, 0x68, 0x3f, 0x4e, 0xe7, 0xcb, 0xe3, 0x7c, 0x3d, 0x5f, 0x7e, 0xce, 0xf2, 0xd6, 0xcf, 0x19, 0xc2, 0x9f, 0xd7, 0xf3, 0xd7, 0x9c, 0x4d, 0xa5, 0x9a,
  0x3c, 0x63, 0xbd, 0xbd, 0xe9, 0x95, 0x15, 0x48, 0x7b, 0xff, 0x30, 0xa2, 0x9a, 0x9b, 0x18, 0x72, 0xf7, 0x82, 0x76, 0xff, 0xe7, 0x16, 0x95, 0x2f, 0x22, 0x65, 0xa9, 0xad, 0xf6, 0x10, 0x2a, 0x68, 0x30, 0x3a, 0xcb, 0x82, 0xa6, 0x6e, 0x61, 0xdd, 0x92, 0x61, 0x8e, 0x93, 0xbd, 0x35, 0x12, 0x59, 0xd7, 0x36, 0x10, 0x80, 0xa7, 0x99, 0x16, 0x23, 0xcb, 0x07, 0x69, 0x1a, 0x68, 0x77, 0xa6, 0x37, 0x63, 0x1d, 0x46, 0x87, 0xa3, 0xdd, 0xaa, 0x71, 0x51, 0x5e, 0xda, 0xd5, 0x23, 0x74, 0x9e, 0x4c, 0x98, 0x28, 0x9b, 0x6d, 0x8d, 0x6e, 0x82, 0x78, 0xc7, 0x9e, 0x99, 0x09, 0x23, 0xdc, 0xd6, 0x4d, 0x57, 0xdb, 0xd3, 0xe2, 0x1d, 0x3d, 0x67, 0x32, 0x4b, 0xc2, 0xb4, 0xb7, 0x10, 0x70, 0x6b, 0x1b, 0x08, 0x79, 0x79, 0x93, 0xfd, 0xc8, 0xd6, 0x0c, 0xba, 0x66, 0x38, 0x90, 0xfa, 0xee, 0xba, 0x6b, 0x05, 0xb5, 0x32, 0x31, 0xfb, 0x46, 0x6a, 0xe6, 0x9c, 0x76, 0xb6, 0x37, 0x45, 0xb7, 0x4b, 0xe8, 0x6b, 0xd8, 0x0a, 0x7f, 0xba, 0xbe, 0x3a, 0x7b, 0x9a, 0x95, 0xf0, 0xef, 0x5d, 0x53, 0xb8, 0xee, 0x0c, 0xd4, 0x31, 0x40, 0xad, 0xd0, 0xef, 0xf7, 0x85, 0xac, 0xcc, 0xfa, 0x0d, 0x03, 0x28, 0x53, 0xbf, 0x06, 0x61, 0x94, 0x49, 0x42, 0x77, 0x96, 0x8a, 0xab, 0x24, 0x81, 0x1d, 0xeb, 0x9d, 0xd1, 0x23, 0xbd, 0xb6, 0x0a, 0xfd, 0x34, 0x2c, 0x49, 0x5b, 0x71, 0x50, 0xa8, 0x9e, 0xab, 0xeb, 0x36, 0x1e, 0x2e, 0xf5, 0xd6, 0x62, 0x79, 0x9d, 0xec, 0xa3, 0x2b, 0x46, 0x99, 0xd5, 0x9b, 0x56, 0x97, 0xb1, 0x41, 0x4c, 0x4d, 0x1a, 0x56, 0x37, 0xda, 0xbe, 0xad, 0x85, 0xdb, 0xd0, 0x3b, 0x43, 0xc8, 0x79, 0xbd, 0xe6, 0x41, 0x30, 0x10, 0x0e, 0x62, 0xa7, 0xed, 0x81, 0x7e, 0x5e, 0x3d, 0x9e, 0xef,
  0xda, 0xa8, 0x16, 0x76, 0xb6, 0x4a, 0xeb, 0xf8, 0xbc, 0x06, 0xaa, 0x0a, 0x9d, 0xd5, 0xe6, 0xca, 0xe9, 0x08, 0x9f, 0x51, 0x36, 0x1c, 0xeb, 0x29, 0x37, 0xaf, 0xe2, 0x1b, 0x6c, 0xab, 0xce, 0xd6, 0x5c, 0xad, 0x32, 0xd5, 0x12, 0xc9, 0x54, 0x67, 0xbf, 0xa4, 0xec, 0xd6, 0xd6, 0x52, 0xe3, 0xd8, 0x03, 0xf6, 0x37, 0xc9, 0x18, 0x58, 0x1e, 0x8a, 0xff, 0x67, 0x00, 0xb1, 0xf7, 0xd5, 0xc1, 0x87, 0x5e, 0x59, 0x1c, 0x73, 0xa5, 0x9d, 0x4e, 0xdd, 0x39, 0x66, 0x69, 0x21, 0xd5, 0x45, 0x3f, 0xfd, 0xea, 0xfe, 0x9a, 0xbb, 0x99, 0x8b, 0x5a, 0x5c, 0xe9, 0xe8, 0xe2, 0xdd, 0x2d, 0xeb, 0xc3, 0x18, 0xd7, 0x5a, 0x9d, 0x6c, 0x8a, 0x8d, 0xf5, 0xdc, 0xa0, 0xa8, 0xe6, 0xff, 0x76, 0x54, 0x6d, 0xa4, 0xb1, 0x4f, 0x2f, 0xf6, 0x8e, 0x10, 0x09, 0xa5, 0xbb, 0x5f, 0x15, 0xf8, 0x9b, 0x4e, 0x55, 0x8f, 0x21, 0xe1, 0x87, 0x0d, 0xd5, 0xca, 0xf6, 0x3d, 0x15, 0x8c, 0x63, 0xea, 0xcb, 0x2e, 0x9d, 0x6c, 0x12, 0xd6, 0x01, 0x7e, 0x18, 0xbc, 0x2e, 0x9a, 0x6c, 0xc6, 0xbe, 0xd5, 0xee, 0x19, 0x48, 0xb9, 0x59, 0xf2, 0x1a, 0x3d, 0xc9, 0x72, 0x31, 0x06, 0x46, 0xed, 0xda, 0x7a, 0x53, 0x14, 0x6c, 0x84, 0x2e, 0x8b, 0xec, 0xb8, 0x6f, 0xf3, 0x8f, 0xa1, 0x4e, 0x7b, 0xa3, 0xef, 0x84, 0x8a, 0x32, 0xbb, 0xbf, 0x3e, 0xf9, 0x4c, 0x7b, 0x23, 0x23, 0x5f, 0x80, 0x20, 0xc4, 0x5d, 0x10, 0xf3, 0xb5, 0x3d, 0x9d, 0x77, 0x4c, 0xdb, 0x17, 0x75, 0xe0, 0x2b, 0x41, 0x3f, 0x0b, 0x82, 0xbb, 0xf2, 0xd0, 0x94, 0xcf, 0x95, 0xfb, 0x4b, 0xfc, 0x59, 0x06, 0x00, 0x95, 0xe8, 0x3b, 0x9a, 0x79, 0xf8, 0xbb, 0xfe, 0x2e, 0xb9, 0xfe, 0x03, 0xe9, 0xa3, 0x1d, 0xa4, 0x0b, 0xb3, 0x85, 0x1e, 0x00, 0x00, 0x00, 0x00,
  0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_nobody_len = 1544;

// icon : vacancy mode (thermostat)
#define PILOTWIRE_ICON_VACANCY "vacancy.png"      
unsigned char pilotwire_vacancy_png[] PROGMEM = {
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x04, 0x03, 0x00, 0x00, 0x00, 0x31, 0x10, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x4d, 0x4b, 0x88, 0x8a, 0x87, 0xff, 0xff, 0xff, 0x9e, 0xd8, 0x1a, 0xfe, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88, 0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x01, 0xb5, 0x7b, 0x52, 0x6b, 0x00, 0x00, 0x01, 0xef, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0x99, 0x6d, 0x8e, 0xc2, 0x20, 0x10, 0x86, 0x4d, 0xe4, 0x02, 0xa0, 0x17, 0xc0, 0xf6, 0x00, 0xd6, 0x72, 0x00, 0x2c, 0x73, 0xff, 0x33, 0x6d, 0xd5, 0xad, 0xf2, 0x31, 0xcb, 0xc7, 0x8c, 0x9b, 0x6c, 0x56, 0xe6, 0x97, 0x26, 0xf2, 0xf8, 0x0c, 0x85, 0xb7, 0x54, 0x77, 0xbb, 0xdf, 0xae, 0xfd, 0x99, 0x09, 0x00, 0xe0, 0x8d, 0x17, 0x00, 0x96, 0x29, 0xc0, 0x53, 0x10, 0x37, 0x80, 0x65, 0x0a, 0x70, 0x14, 0xc4, 0x03, 0x60, 0x99, 0x02, 0x74, 0x85, 0xfd, 0x06, 0xa0, 0x2a, 0x18, 0xe0, 0x29, 0x3c, 0x05, 0xa8, 0x0a, 0x2f, 0x01, 0x9a, 0x82, 0x27, 0x40, 0x53, 0xf0, 0x05, 0xbe, 0x15, 0xf6, 0x4d, 0xb4, 0x60, 0xfc, 0x63, 0x90, 0x69, 0x69, 0x48, 0x84, 0x00, 0xd7, 0xbc, 0x2e, 0x20, 0xaa, 0x73, 0x23, 0x40, 0xc4, 0x00, 0xd7, 0x08, 0x00, 0x40, 0x14, 0x1a, 0x00, 0x22, 0x05, 0xd8, 0x26, 0x00, 0x20, 0xd5, 0x02, 0x10, 0x18, 0xc0, 0x36, 0x00, 0x00, 0xad,
  0x7a, 0x80, 0xc0, 0x01, 0xae, 0x1a, 0x00, 0x85, 0x22, 0x0a, 0xd4, 0x03, 0x80, 0x09, 0x10, 0x5c, 0x80, 0x61, 0x02, 0xca, 0x02, 0xc0, 0x15, 0x80, 0xfa, 0x24, 0xa3, 0x00, 0x0c, 0x13, 0x50, 0x23, 0x00, 0x5c, 0x01, 0xe0, 0x0a, 0x00, 0xef, 0x1a, 0xe6, 0x01, 0xc0, 0x04, 0x08, 0x2e, 0x00, 0x98, 0x80, 0x44, 0x60, 0xbe, 0x0c, 0x73, 0x0b, 0x20, 0x4e, 0x20, 0x2d, 0xd7, 0x52, 0xa6, 0x1a, 0x10, 0xdf, 0xcd, 0xe4, 0xa3, 0x52, 0x82, 0xad, 0x12, 0x58, 0xc7, 0x0f, 0xe6, 0xae, 0xa1, 0x2a, 0x15, 0x22, 0x81, 0x49, 0x0e, 0xdb, 0x8b, 0x43, 0x9d, 0x42, 0x2c, 0xf0, 0x1c, 0xa6, 0xa5, 0xa9, 0x51, 0x88, 0x05, 0x5e, 0xad, 0xbb, 0x3a, 0x85, 0x58, 0x60, 0xf4, 0xbb, 0xa9, 0x98, 0x85, 0x48, 0x60, 0x91, 0xc1, 0x9b, 0xb1, 0xac, 0x10, 0x7d, 0x60, 0x0a, 0xac, 0xd3, 0x1e, 0xa0, 0xb4, 0x08, 0xc3, 0xef, 0x9c, 0x14, 0x76, 0x5c, 0xc8, 0x2e, 0xc2, 0x70, 0xe2, 0xaf, 0xe9, 0x75, 0x70, 0xf9, 0x20, 0x59, 0x54, 0x8e, 0x87, 0x28, 0x98, 0xec, 0x14, 0xac, 0x80, 0x23, 0x64, 0x15, 0x92, 0x24, 0x8b, 0x00, 0xa0, 0x0f, 0x90, 0x55, 0x48, 0x04, 0xf5, 0xb1, 0x0c, 0x70, 0xb9, 0x20, 0xd1, 0x63, 0xbc, 0x2e, 0x21, 0xa7, 0x90, 0x26, 0x59, 0x3c, 0x69, 0x28, 0xc0, 0x66, 0x92, 0x2c, 0x06, 0x5c, 0x55, 0x2e, 0xda, 0x04, 0x15, 0x60, 0xff, 0x0c, 0x20, 0x99, 0x03, 0x37, 0xcb, 0x61, 0x0e, 0x6a, 0x52, 0x48, 0x3a, 0x9b, 0x1f, 0x37, 0x93, 0x96, 0x48, 0x1d, 0x0a, 0xfb, 0x19, 0x89, 0xe3, 0xb0, 0x54, 0x21, 0x51, 0x84, 0x0f, 0x98, 0xd3, 0xba, 0xa8, 0x52, 0xa6, 0xf9, 0x00, 0x64, 0xc2, 0x96, 0x37, 0x03, 0x76, 0x1d, 0xf0, 0x41, 0x00, 0x77, 0x1a, 0x78, 0x80, 0x75, 0x57, 0x8d, 0x1c, 0xc0, 0xe2,
  0xed, 0x21, 0x12, 0x60, 0x8d, 0xd2, 0x65, 0x8b, 0x16, 0x12, 0xe0, 0x76, 0x37, 0xd8, 0x7a, 0xa0, 0x01, 0x8e, 0xaf, 0x3b, 0x04, 0xdd, 0x80, 0xd3, 0xc2, 0x24, 0xcd, 0x85, 0x05, 0x60, 0x5f, 0x05, 0xf6, 0x3a, 0xf0, 0x0f, 0x16, 0xc4, 0xbd, 0xd0, 0x01, 0x1d, 0x70, 0x7f, 0x6c, 0xeb, 0xb1, 0xfe, 0xc9, 0x80, 0x53, 0x5a, 0xba, 0x09, 0x50, 0x3e, 0xe6, 0xe5, 0x1f, 0x3c, 0xd1, 0x83, 0xe6, 0xd0, 0x00, 0xa0, 0xfd, 0x88, 0xd1, 0x01, 0x1d, 0xd0, 0x01, 0xff, 0x06, 0x60, 0xb8, 0x00, 0xc1, 0x05, 0x34, 0xf5, 0x80, 0xff, 0x1e, 0x38, 0x57, 0x17, 0xf7, 0x0f, 0xf9, 0x77, 0xd6, 0x17, 0x45, 0xe1, 0xdd, 0xa1, 0x0b, 0x7a, 0x91, 0x04, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
unsigned int pilotwire_vacancy_len = 626;

/*****************************************\
 *               Variables
\*****************************************/

// pilotwire : configuration
struct {
  bool    window_open = false;                          // enable window open detection
  bool    mvt_detect  = false;                          // enable movement detection
  uint8_t device_type = UINT8_MAX;                      // pilotwire or direct connexion
  uint8_t device_mode = UINT8_MAX;                      // running mode (off, on, thermostat)
  float   arr_target[PILOTWIRE_TEMP_MAX];               // array of target temperatures (according to status)
} pilotwire_config;

// pilotwire : general status
struct {
  uint8_t  device_state     = PILOTWIRE_STATUS_OFF;      // at startup, device state is considered OFF
  uint8_t  device_mode      = PILOTWIRE_STATUS_OFF;      // start heater OFF
  uint8_t  heating_mode     = PILOTWIRE_HEATING_OFF;     // heating is OFF at startup
  uint8_t  next_mode        = PILOTWIRE_STATUS_NORMAL;   // next status
  uint32_t next_time        = UINT32_MAX;                // next time status should change
  uint32_t last_time        = UINT32_MAX;                // last time status has changed
  uint8_t  json_update      = false;                     // flag to publish a json update
  float    json_temperature = NAN;                       // last published temperature
} pilotwire_status;

// pilotwire : temperature data
struct {
  uint32_t source  = UINT32_MAX;                        // type of temperature sensor
  float    current = NAN;                               // current temperature
  float    target  = NAN;                               // target temperature
} pilotwire_temperature;

// pilotwire : open window detection
struct {
  bool    opened   = false;                             // open window active
  float   low_temp = NAN;                               // lower temperature during open window phase
  uint8_t period   = 0;                                 // period for temperature measurement (sec)
  uint8_t idx_temp = 0;                                 // current index of temperature array
  float   arr_temp[PILOTWIRE_WINDOW_SAMPLE_NBR];        // array of values to detect open window
} pilotwire_window;

// pilotwire : movement detection
struct {
  bool     present = false;                             // enable movement detection   
  bool     active  = false;                             // movement actually detected   
  uint32_t last    = UINT32_MAX;                        // last movement detection timestamp
} pilotwire_mvt;

// pilotwire : graph data
struct {
  float    temp_min = NAN;                                                // graph minimum temperature
  float    temp_max = NAN;                                                // graph maximum temperature
  uint8_t  device_state[PILOTWIRE_PERIOD_MAX];                            // graph periods device state
  uint32_t index[PILOTWIRE_PERIOD_MAX];                                   // current graph index for data
  uint32_t counter[PILOTWIRE_PERIOD_MAX];                                 // graph update counter
  float    temperature[PILOTWIRE_PERIOD_MAX];                             // graph current temperature
  short    arr_temp[PILOTWIRE_PERIOD_MAX][PILOTWIRE_GRAPH_SAMPLE];        // graph temperature array (value x 10)
  short    arr_target[PILOTWIRE_PERIOD_MAX][PILOTWIRE_GRAPH_SAMPLE];      // graph target temperature array (value x 10)
  uint8_t  arr_state[PILOTWIRE_PERIOD_MAX][PILOTWIRE_GRAPH_SAMPLE];       // graph command state array
} pilotwire_graph;

/******************************************************\
 *                     Functions
\******************************************************/

// get pilotwire device state from relay state
uint8_t PilotwireGetDeviceState ()
{
  uint8_t relay = 0;
  uint8_t state = 0;
    
  // read relay state
  relay = bitRead (TasmotaGlobal.power, 0);

  // if pilotwire connexion, convert to pilotwire state
  if (pilotwire_config.device_type == PILOTWIRE_DEVICE_NORMAL) { if (relay == 0) state = PILOTWIRE_STATUS_ON; else state = PILOTWIRE_STATUS_OFF; }

  // else, direct connexion, convert to pilotwire state
  else { if (relay == 0) state = PILOTWIRE_STATUS_OFF; else state = PILOTWIRE_STATUS_ON; }

  return state;
}

// set relays state
void PilotwireSetDeviceState (uint8_t new_state)
{
  uint32_t new_power = UINT32_MAX;

  // if pilotwire connexion
  if (pilotwire_config.device_type == PILOTWIRE_DEVICE_NORMAL)
  {
    // set power state according to mode
    if (new_state == PILOTWIRE_STATUS_OFF) ExecuteCommandPower (1, POWER_ON, SRC_MAX);
    else if (new_state == PILOTWIRE_STATUS_ON) ExecuteCommandPower (1, POWER_OFF, SRC_MAX);    
  }

  // else direct connexion
  else
  {
    // set power state according to mode
    if (new_state == PILOTWIRE_STATUS_OFF) ExecuteCommandPower (1, POWER_OFF, SRC_MAX);
    else if (new_state == PILOTWIRE_STATUS_ON) ExecuteCommandPower (1, POWER_ON, SRC_MAX);
  }

  // ask for JSON update
  pilotwire_status.json_update = true;
}

// read target temperature according to running status
float PilotwireGetCurrentTargetTemperature ()
{
  uint8_t  device_status;
  uint32_t delay;
  float    temperature, target, multiply;

  // switch according to temperature type
  device_status = pilotwire_status.device_mode;
  switch (device_status)
  {
    case PILOTWIRE_STATUS_NORMAL:
      target = pilotwire_temperature.target;
      break;

    case PILOTWIRE_STATUS_NIGHT:
    case PILOTWIRE_STATUS_VACANCY:
      if (pilotwire_config.arr_target[device_status] > 0) target = pilotwire_config.arr_target[device_status];
      else target = pilotwire_temperature.target + pilotwire_config.arr_target[device_status];
      break;

    case PILOTWIRE_STATUS_NOBODY:
      // calculate delay since switch to NOBODY status (in sec)
      delay = LocalTime () - pilotwire_status.last_time;

      // calculate temperature decrease
      if (pilotwire_config.arr_target[PILOTWIRE_STATUS_NOBODY] > 0) target = pilotwire_config.arr_target[PILOTWIRE_STATUS_NOBODY];
      else target = pilotwire_temperature.target + pilotwire_config.arr_target[PILOTWIRE_STATUS_NOBODY];
      multiply = (float)delay / 60 / PILOTWIRE_MOVEMENT_NOBODY_DROP;
      temperature = pilotwire_config.arr_target[PILOTWIRE_STATUS_NORMAL] - (multiply * 0.5);
      target = max (target, temperature);
      break;

    default:
      target = NAN;
      break;
  }

  // validate boundaries
  if (target < PILOTWIRE_TEMP_LIMIT_MIN) target = PILOTWIRE_TEMP_LIMIT_MIN;
  else if (target > PILOTWIRE_TEMP_LIMIT_MAX) target = PILOTWIRE_TEMP_LIMIT_MAX;

  return target;
}

// set different running temperatures
void PilotwireSetTemperature (uint8_t new_type, float new_temp, bool to_save = true)
{
  bool is_valid = false;
  char str_type[16];

  if (new_type < PILOTWIRE_TEMP_MAX)
  {
    // check validity
    if (new_temp < 0) is_valid = true;
    else if ((new_temp > 0) && (new_temp >= PILOTWIRE_TEMP_LIMIT_MIN) && (new_temp <= PILOTWIRE_TEMP_LIMIT_MAX)) is_valid = true;

    // if valid, save temperature
    if (is_valid)
    {
      // set temperature and save config
      pilotwire_config.arr_target[new_type] = new_temp;
      if (to_save) PilotwireSaveConfig ();
      GetTextIndexed (str_type, sizeof (str_type), new_type, kPilotwireTemperature);
      AddLog (LOG_LEVEL_INFO, PSTR ("PIL: %s temperature set"), str_type);
    }
  }
}

// set heater configuration mode
void PilotwireSetDeviceType (uint8_t new_type, bool to_save = true)
{
  char str_type[16];

  if (new_type < PILOTWIRE_DEVICE_MAX)
  {
    // set type
    pilotwire_config.device_type = new_type;

    // save and log action
    if (to_save) PilotwireSaveConfig ();
    GetTextIndexed (str_type, sizeof (str_type), pilotwire_config.device_type, kPilotwireDevice);
    AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Device set to %s"), str_type);
  }
}

// set heater status mode
void PilotwireSetStatusMode (uint8_t new_mode, bool forced = false)
{
  uint8_t target_mode = UINT8_MAX;
  char    str_mode[16];

  // switch action according to mode
  switch (new_mode)
  {
    // switch heater off
    case PILOTWIRE_STATUS_OFF:
      if (forced || (pilotwire_status.device_mode != PILOTWIRE_STATUS_OFF))
      {
        // set target mode
        target_mode = PILOTWIRE_STATUS_OFF;
        pilotwire_status.next_mode = PILOTWIRE_STATUS_OFF;
        pilotwire_status.next_time = UINT32_MAX;

        // if forced, reset target temperature
        if (forced) pilotwire_temperature.target = NAN;
      }
      break;

    // force heater ON
    case PILOTWIRE_STATUS_ON:
      if (forced || (pilotwire_status.device_mode != PILOTWIRE_STATUS_ON))
      {
        // set target mode
        target_mode = PILOTWIRE_STATUS_ON;
        pilotwire_status.next_mode = PILOTWIRE_STATUS_ON;
        pilotwire_status.next_time = UINT32_MAX;

        // if forced, reset target temperature
        if (forced) pilotwire_temperature.target = NAN;
      }
      break;

    // set heater in normal thermostat mode
    case PILOTWIRE_STATUS_NORMAL:
      // set target mode
      target_mode = PILOTWIRE_STATUS_NORMAL;
      if (pilotwire_config.mvt_detect && pilotwire_mvt.present)
      {
        pilotwire_status.next_mode = PILOTWIRE_STATUS_NOBODY;
        pilotwire_status.next_time = LocalTime () + (PILOTWIRE_MOVEMENT_NOBODY_START * 60);
      }
      else
      {
        pilotwire_status.next_mode = PILOTWIRE_STATUS_NORMAL;
        pilotwire_status.next_time = UINT32_MAX;
      }

      // if forced, set target temperature
      if (forced) pilotwire_temperature.target = pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL];
      break;

    // set heater in night thermostat mode
    case PILOTWIRE_STATUS_NIGHT:
      // if forced or actual status is NORMAL
      if (forced || (pilotwire_status.device_mode == PILOTWIRE_STATUS_NORMAL))
      {
        // set target mode
        target_mode = PILOTWIRE_STATUS_NIGHT;
        pilotwire_status.next_mode = PILOTWIRE_STATUS_NORMAL;
        pilotwire_status.next_time = UINT32_MAX;
      }
      break;

    // set heater in nobody thermostat mode
    case PILOTWIRE_STATUS_NOBODY:
      // if forced or actual status is NORMAL
      if (forced || (pilotwire_status.device_mode == PILOTWIRE_STATUS_NORMAL))
      {
        // set target mode
        target_mode = PILOTWIRE_STATUS_NOBODY;
        pilotwire_status.next_mode = PILOTWIRE_STATUS_VACANCY;
        pilotwire_status.next_time = LocalTime () + (PILOTWIRE_MOVEMENT_VACANCY_START * 60);
      }
      break;

    // set heater in vacancy thermostat mode
    case PILOTWIRE_STATUS_VACANCY:
      // if forced or actual status is NOBODY
      if (forced || (pilotwire_status.device_mode == PILOTWIRE_STATUS_NOBODY))
      {
        // set target mode
        target_mode = PILOTWIRE_STATUS_VACANCY;
        pilotwire_status.next_mode = PILOTWIRE_STATUS_VACANCY;
        pilotwire_status.next_time = UINT32_MAX;
      }
      break;
  }

  // if status should change
  if (target_mode != UINT8_MAX)
  {
    // set new status mode
    pilotwire_status.last_time   = LocalTime ();
    pilotwire_status.device_mode = target_mode;

    // reset open window detection
    PilotwireWindowResetDetection ();

    // ask for JSON update
    pilotwire_status.json_update = true;

    // log change
    GetTextIndexed (str_mode, sizeof (str_mode), target_mode, kPilotwireStatus);
    AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Switch status to %s"), str_mode);
  }
}

// update movement detection status
void PilotwireMovementUpdateDetection ()
{
  bool     mvt_detected;
  uint32_t timestamp;

  timestamp = LocalTime ();

  // check if movement is actually detected 
  mvt_detected = (Switch.virtual_state[0] == 1);

  // if movement just detected, set movement status
  if (mvt_detected && !pilotwire_mvt.active) pilotwire_mvt.active = true;

  // if movement actually detected
  if (mvt_detected)
  {
    // update last detection timestamp
    pilotwire_mvt.last = timestamp;

    // if needed, set back status to NORMAL
    if ((pilotwire_status.device_mode == PILOTWIRE_STATUS_NOBODY) || (pilotwire_status.device_mode == PILOTWIRE_STATUS_VACANCY)) 
      PilotwireSetStatusMode (PILOTWIRE_STATUS_NORMAL);
  }

  // else, if no movement after detection timeout, 
  else if (pilotwire_mvt.active && (timestamp > pilotwire_mvt.last + PILOTWIRE_MOVEMENT_TIMEOUT))
  {
    // reset movement detection
    pilotwire_mvt.active = false;

    // set next mode to NOBODY
    pilotwire_status.next_mode = PILOTWIRE_STATUS_NOBODY;
    pilotwire_status.next_time = timestamp + (PILOTWIRE_MOVEMENT_NOBODY_START * 60);
  }
}

// reset window detection data
void PilotwireWindowResetDetection ()
{
  uint8_t index;

  // declare window closed
  pilotwire_window.opened   = false;
  pilotwire_window.low_temp = NAN;

  // reset detection temperatures
  for (index = 0; index < PILOTWIRE_WINDOW_SAMPLE_NBR; index ++) pilotwire_window.arr_temp[index] = NAN;
}

// update opened window detection data
void PilotwireWindowUpdateDetection ()
{
  uint8_t index, idx_array;
  float   delta = 0;

  // if window considered closed, do open detection
  if (!pilotwire_window.opened)
  {
    // if temperature is available, update temperature detection array
    if (!isnan (pilotwire_temperature.current))
    {
      // if period reached
      if (pilotwire_window.period == 0)
      {
        // record temperature and increment index
        pilotwire_window.arr_temp[pilotwire_window.idx_temp] = pilotwire_temperature.current;
        pilotwire_window.idx_temp++;
        pilotwire_window.idx_temp = pilotwire_window.idx_temp % PILOTWIRE_WINDOW_SAMPLE_NBR;
      }

      // increment period counter
      pilotwire_window.period++;
      pilotwire_window.period = pilotwire_window.period % PILOTWIRE_WINDOW_OPEN_PERIOD;
    }

    // loop thru last measured temperatures
    for (index = 0; index < PILOTWIRE_WINDOW_SAMPLE_NBR; index ++)
    {
      // calculate temperature array in reverse order
      idx_array = (PILOTWIRE_WINDOW_SAMPLE_NBR + pilotwire_window.idx_temp - index - 1) % PILOTWIRE_WINDOW_SAMPLE_NBR;

      // calculate temperature delta 
      if (!isnan (pilotwire_window.arr_temp[idx_array])) delta = max (delta, pilotwire_window.arr_temp[idx_array] - pilotwire_temperature.current);

      // if temperature drop detected, stop analysis
      if (delta >= PILOTWIRE_WINDOW_OPEN_DROP) break;
    }

    // if temperature drop detected, window is detected as opended
    if (delta >= PILOTWIRE_WINDOW_OPEN_DROP)
    {
      pilotwire_window.opened   = true;
      pilotwire_window.low_temp = pilotwire_temperature.current;
    }
  }

  // else, window detected as opened, try to detect closure
  else
  {
    // update lower temperature
    pilotwire_window.low_temp = min (pilotwire_window.low_temp, pilotwire_temperature.current);

    // if current temperature has increased enought, window is closed
    if (pilotwire_temperature.current - pilotwire_window.low_temp > PILOTWIRE_WINDOW_CLOSE_INCREASE) PilotwireWindowResetDetection ();
  }
}

// set heater configuration mode
void PilotwireSetConfigMode (uint8_t new_mode, bool to_save = true)
{
  char str_mode[16];

  // switch action according to mode
  switch (new_mode)
  {
    // switch OFF heater
    case PILOTWIRE_CONFIG_OFF:
      pilotwire_config.device_mode = PILOTWIRE_CONFIG_OFF;
      PilotwireSetStatusMode (PILOTWIRE_STATUS_OFF, true);
      break;

    // force heater ON
    case PILOTWIRE_CONFIG_ON:
      pilotwire_config.device_mode = PILOTWIRE_CONFIG_ON;
      PilotwireSetStatusMode (PILOTWIRE_STATUS_ON, true);
      break;

    // set heater in thermostat mode
    case PILOTWIRE_CONFIG_THERM:
      pilotwire_config.device_mode = PILOTWIRE_CONFIG_THERM;
      if (pilotwire_status.device_mode < PILOTWIRE_STATUS_NORMAL) PilotwireSetStatusMode (PILOTWIRE_STATUS_NORMAL, true);
      break;
  }

  // save and log action
  if (to_save) PilotwireSaveConfig ();
  GetTextIndexed (str_mode, sizeof (str_mode), pilotwire_config.device_mode, kPilotwireConfig);
  AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Switch config to %s"), str_mode);
}

// set current target temperature
void PilotwireSetCurrentTarget (float target)
{
  char str_value[8];

  // if target is within range
  if ((target >= pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) && (target <= pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]))
  {
    // set normal thermostat mode and target temperature
    PilotwireSetStatusMode (PILOTWIRE_STATUS_NORMAL);
    pilotwire_temperature.target = target;

    // log new target
    ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%01_f"), &pilotwire_temperature.target);
    AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Set target temp. to %s"), str_value);
  }

  // update JSON
  pilotwire_status.json_update = true;
}

/**************************************************\
 *                  Commands
\**************************************************/

void CmndPilotwireType ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetDeviceType ((uint8_t)XdrvMailbox.payload);
  ResponseCmndNumber (pilotwire_config.device_type);
}

void CmndPilotwireMode ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetConfigMode ((uint8_t)XdrvMailbox.payload);
  ResponseCmndNumber (pilotwire_config.device_mode);
}

void CmndPilotwireTarget ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetCurrentTarget (atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_temperature.target, 1);
}

void CmndPilotwireWindow ()
{
  if (XdrvMailbox.data_len > 0) pilotwire_config.window_open = (XdrvMailbox.payload != 0);
  ResponseCmndNumber (pilotwire_config.window_open);
}

void CmndPilotwireMvtDetect ()
{
  if (XdrvMailbox.data_len > 0) pilotwire_config.mvt_detect = (XdrvMailbox.payload != 0);
  ResponseCmndNumber (pilotwire_config.mvt_detect);
}

void CmndPilotwireStatus ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetStatusMode ((uint8_t)XdrvMailbox.payload, true);
  ResponseCmndNumber (pilotwire_status.device_mode);
}

void CmndPilotwireLow ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_LOW, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW], 1);
}

void CmndPilotwireHigh ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_HIGH, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH], 1);
}

void CmndPilotwireNormal ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NORMAL, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL], 1);
}

void CmndPilotwireNight ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NIGHT, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT], 1);
}

void CmndPilotwireNobody ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NOBODY, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY], 1);
}

void CmndPilotwireVacancy ()
{
  if (XdrvMailbox.data_len > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_VACANCY, atof(XdrvMailbox.data));
  ResponseCmndFloat (pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY], 1);
}

/**************************************************\
 *                  Configuration
\**************************************************/

void PilotwireLoadConfig () 
{
  uint8_t device_mode;

#ifdef USE_UFILESYS

  // retrieve saved settings from flash filesystem
  device_mode = (uint8_t)UfsCfgLoadKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_MODE, 0);
  pilotwire_config.device_type = (uint8_t)UfsCfgLoadKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_TYPE, 0);
  pilotwire_config.window_open = (bool)UfsCfgLoadKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_WINDOW, 0);
  pilotwire_config.mvt_detect  = (bool)UfsCfgLoadKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_MVT, 0);

  pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_LOW, PILOTWIRE_TEMP_DEFAULT_LOW);
  pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_HIGH, PILOTWIRE_TEMP_DEFAULT_HIGH);
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NORMAL, PILOTWIRE_TEMP_DEFAULT_NORMAL);
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NIGHT, 0);
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NOBODY, 0);
  pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] = UfsCfgLoadKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_VACANCY, 0);

  // log
  AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Config from LittleFS"));

#else       // No LittleFS

  // retrieve saved settings from flash memory
  device_mode = (uint8_t)Settings->knx_CB_addr[0];
  pilotwire_config.device_type = (uint8_t)Settings->knx_CB_addr[1];
  pilotwire_config.window_open = (bool)Settings->knx_CB_addr[8];
  pilotwire_config.mvt_detect  = (bool)Settings->knx_CB_addr[9];

  pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]     = (float)Settings->knx_CB_addr[2] / 10;
  pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]    = (float)Settings->knx_CB_addr[3] / 10;
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL]  = (float)Settings->knx_CB_addr[4] / 10;
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT]   = ((float)Settings->knx_CB_addr[5] - 1000) / 10;
  pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY]  = ((float)Settings->knx_CB_addr[6] - 1000) / 10;
  pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] = ((float)Settings->knx_CB_addr[7] - 1000) / 10;
   // log
  AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Config from Settings"));

# endif     // USE_UFILESYS

  // avoid values out of range
  if (device_mode >= PILOTWIRE_CONFIG_MAX) device_mode = PILOTWIRE_CONFIG_THERM;
  if (pilotwire_config.device_type > PILOTWIRE_DEVICE_DIRECT) pilotwire_config.device_type = PILOTWIRE_DEVICE_NORMAL;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW] < PILOTWIRE_TEMP_LIMIT_MIN) pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW] = PILOTWIRE_TEMP_DEFAULT_LOW;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW] > PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW] = PILOTWIRE_TEMP_DEFAULT_LOW;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] < PILOTWIRE_TEMP_LIMIT_MIN) pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] = PILOTWIRE_TEMP_DEFAULT_HIGH;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] > PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] = PILOTWIRE_TEMP_DEFAULT_HIGH;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL] < PILOTWIRE_TEMP_LIMIT_MIN) pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL] = PILOTWIRE_TEMP_DEFAULT_NORMAL;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL] > PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL] = PILOTWIRE_TEMP_DEFAULT_NORMAL;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT] < -PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT] = 0;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT] >  PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT] = 0;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY] < -PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY] = 0;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY] >  PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY] = 0;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] < -PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] = 0;
  if (pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] >  PILOTWIRE_TEMP_LIMIT_MAX) pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY] = 0;

  // set configuration mode without saving it back
  PilotwireSetConfigMode (device_mode, false);
}

void PilotwireSaveConfig () 
{
#ifdef USE_UFILESYS

  // save settings into flash filesystem
  UfsCfgSaveKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_MODE, (int)pilotwire_config.device_mode, true);
  UfsCfgSaveKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_TYPE, (int)pilotwire_config.device_type, false);
  UfsCfgSaveKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_WINDOW, (int)pilotwire_config.window_open, false);
  UfsCfgSaveKeyInt (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_MVT, (int)pilotwire_config.mvt_detect, false);

  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_LOW, pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW], false);
  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_HIGH, pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH], false);
  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NORMAL, pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL], false);
  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NIGHT, pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT], false);
  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_NOBODY, pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY], false);
  UfsCfgSaveKeyFloat (D_PILOTWIRE_FILE_CFG, D_CMND_PILOTWIRE_VACANCY, pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY], false);

# else       // No LittleFS

  // save settings into flash memory
  Settings->knx_CB_addr[0] = (uint16_t)pilotwire_config.device_mode;
  Settings->knx_CB_addr[1] = (uint16_t)pilotwire_config.device_type;
  Settings->knx_CB_addr[8] = (uint16_t)pilotwire_config.window_open;
  Settings->knx_CB_addr[9] = (uint16_t)pilotwire_config.mvt_detect;

  Settings->knx_CB_addr[2] = (uint16_t)(10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]);
  Settings->knx_CB_addr[3] = (uint16_t)(10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]);
  Settings->knx_CB_addr[4] = (uint16_t)(10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL]);
  Settings->knx_CB_addr[5] = (uint16_t)(1000 + (10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT]));
  Settings->knx_CB_addr[6] = (uint16_t)(1000 + (10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY]));
  Settings->knx_CB_addr[7] = (uint16_t)(1000 + (10 * pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY]));

# endif     // USE_UFILESYS
}

/******************************************************\
 *                  Historical files
\******************************************************/

#ifdef USE_UFILESYS

// clean and rotate histo files
void PilotwireHistoRotate ()
{
  TIME_T time_dst;

  // extract data from current time
  BreakTime (LocalTime (), time_dst);

  // if we are monday, rotate weekly files
  if (time_dst.day_of_week == 2) UfsCsvFileRotate (D_PILOTWIRE_HISTO_FILE_WEEK, 0, PILOTWIRE_HISTO_WEEK_MAX);

  // clean old CSV files
  UfsCsvCleanupFileSystem (PILOTWIRE_HISTO_MIN_FREE);
}

// save current data to histo file
void PilotwireHistoSaveData (uint32_t period)
{
  long     index;
  float    temperature;
  TIME_T   now_dst;
  char str_filename[UFS_FILENAME_SIZE];
  char str_value[32];
  char str_line[UFS_CSV_LINE_LENGTH];

  // validate period value
  if (period != PILOTWIRE_PERIOD_WEEK) return;

  // extract current time data
  BreakTime (LocalTime (), now_dst);

  // set target is weekly records
  sprintf_P (str_filename, PSTR (D_PILOTWIRE_HISTO_FILE_WEEK), 0);

  // generate current line
  index = (((now_dst.day_of_week + 5) % 7) * 86400 + now_dst.hour * 3600 + now_dst.minute * 60) / ARR_PILOTWIRE_PERIOD_SAMPLE[period];
  sprintf_P (str_line, PSTR ("%d;%02u/%02u;%02u:%02u"), index, now_dst.day_of_month, now_dst.month, now_dst.hour, now_dst.minute);

  // append actual temperature
  ext_snprintf_P (str_value, sizeof (str_value), PSTR (";%1_f"), &pilotwire_temperature.current);
  strlcat (str_line, str_value, sizeof (str_line));

  // append target temperature
  temperature = PilotwireGetCurrentTargetTemperature ();
  ext_snprintf_P (str_value, sizeof (str_value), PSTR (";%1_f"), &temperature);
  strlcat (str_line, str_value, sizeof (str_line));

  // append heater status
  sprintf_P (str_value, PSTR (";%d"), PilotwireGetDeviceState ());
  strlcat (str_line, str_value, sizeof (str_line));

  // if file doesn't exist, add header
  if (!ffsp->exists (str_filename)) UfsCsvAppend (str_filename, "Idx;Date;Time;Temp;Target;Status", true);

  // add current line
  UfsCsvAppend (str_filename, str_line, false);
}

# endif     // USE_UFILESYS


// intercept command to relay 
//  - if coming from timer : relay ON = switch to night mode, relay OFF = switch back to normal mode
//  - if coming from anything else than SRC_MAX : ignore
bool PilotwireSetDevicePower ()
{
  bool     result = false;
  uint32_t target;

  // if command is from a timer, handle night mode
  if (XdrvMailbox.payload == SRC_TIMER)
  {
    // get target state of first relay (off = normal, on = night mode)
    target = XdrvMailbox.index & 1;

    // if relay OFF and night mode ON : night mode should be disabled
    if (!target && (pilotwire_status.device_mode == PILOTWIRE_STATUS_NIGHT)) PilotwireSetStatusMode (PILOTWIRE_STATUS_NORMAL);
 
    // relay ON and normal mode : night mode should be enabled
    else if (target && (pilotwire_status.device_mode == PILOTWIRE_STATUS_NORMAL)) PilotwireSetStatusMode (PILOTWIRE_STATUS_NIGHT);

    // ignore action
    result = true;
  }

  // else if command is not from the module, ignore it
  else if (XdrvMailbox.payload != SRC_MAX)
  {
    // log
    AddLog (LOG_LEVEL_INFO, PSTR ("PIL: Relay order ignored from %u"), XdrvMailbox.payload);

    // ignore action
    result = true;
  }

  return result;
}

// Rotate files at day change
void PilotwireRotateAtMidnight ()
{
#ifdef USE_UFILESYS
  // if filesystem is available, save data to history file
  if (ufs_type) PilotwireHistoRotate ();

#endif    // USE_UFILESYS
}

// Show JSON status (for MQTT)
void PilotwireShowJSON (bool is_autonomous)
{
  float temperature;
  char  str_value[16];

  // add , in append mode or { in direct publish mode
  if (is_autonomous) Response_P (PSTR ("{"));
    else ResponseAppend_P (PSTR (","));

  // add pilotwire data
  //   "PilotWire":{"Mode":2,"Status":4,"Temperature":18.6,"Target":21.0,"Detect":262}
  ResponseAppend_P (PSTR ("\"%s\":{"), D_JSON_PILOTWIRE);

  // current mode
  ResponseAppend_P (PSTR ("\"%s\":%d"), D_JSON_PILOTWIRE_MODE, pilotwire_config.device_mode);

  // current status
  ResponseAppend_P (PSTR (",\"%s\":%d"), D_JSON_PILOTWIRE_STATUS, pilotwire_status.device_mode);

  // heating state
  ResponseAppend_P (PSTR (",\"%s\":%d"), D_JSON_PILOTWIRE_HEATING, pilotwire_status.heating_mode);

  // add current temperature
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_temperature.current);
  ResponseAppend_P (PSTR (",\"%s\":%s"), D_JSON_PILOTWIRE_TEMPERATURE, str_value);

  // target temperature
  temperature = PilotwireGetCurrentTargetTemperature ();
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  ResponseAppend_P (PSTR (",\"%s\":%s"), D_JSON_PILOTWIRE_TARGET, str_value);

  // if movement detection enabled, add last detection (in minutes)
  if (pilotwire_mvt.last != UINT32_MAX) ResponseAppend_P (PSTR (",\"%s\":%u"), D_JSON_PILOTWIRE_DETECT, (LocalTime () - pilotwire_mvt.last) / 60);

  ResponseAppend_P (PSTR ("}"));

  // publish it if not in append mode
  if (is_autonomous)
  {
    // add offload status
    OffloadShowJSON (false);

    // publish message
    ResponseAppend_P (PSTR ("}"));
    MqttPublishTeleSensor ();
  } 

  // reset update flag and update switch status
  pilotwire_status.json_update      = false;
  pilotwire_status.json_temperature = pilotwire_temperature.current;
}

void PilotwireUpdateGraph (uint32_t period)
{
  uint32_t index;
  float    value;

  // check period validity
  if (period >= PILOTWIRE_PERIOD_MAX) return;

  // get graph index
  index = pilotwire_graph.index[period];

  // if live update
  if (period == PILOTWIRE_PERIOD_LIVE)
  {
    // if temperature has been mesured, update current graph index
    if (!isnan (pilotwire_temperature.current) && (index < PILOTWIRE_GRAPH_SAMPLE))
    {
      // set current temperature
      value = pilotwire_temperature.current * 10;
      pilotwire_graph.arr_temp[period][index] = (short)value;

      // set target temperature
      value = pilotwire_temperature.target * 10;
      pilotwire_graph.arr_target[period][index] = (short)value;

      // set pilotwire state
      pilotwire_graph.arr_state[period][index] = pilotwire_graph.device_state[period];
    }
  }

#ifdef USE_UFILESYS
  // else save data to history file
  else if (period == PILOTWIRE_PERIOD_WEEK)
  {
    // if filesystem is available, save data
    if (ufs_type) PilotwireHistoSaveData (period);
  }
#endif    // USE_UFILESYS

  // increase temperature data index and reset if max reached
  index++;
  pilotwire_graph.index[period] = index % PILOTWIRE_GRAPH_SAMPLE;

  // set graph updated flag and init graph values
  pilotwire_graph.device_state[period] = UINT8_MAX;
}

// update pilotwire status
void PilotwireEvery250ms ()
{
  bool    is_offloaded;
  uint8_t device_state, target_state, target_heating;
  float   target_temp;

  // update device state et set target state identical
  pilotwire_status.device_state = PilotwireGetDeviceState ();
  target_state = pilotwire_status.device_state;
  is_offloaded = OffloadIsOffloaded ();

  // -----------------------
  //   Update target state
  // -----------------------

  // if device is offloaded, target state is off
  if (is_offloaded) target_state = PILOTWIRE_STATUS_OFF;

  // else if status is OFF
  else if (pilotwire_status.device_mode == PILOTWIRE_STATUS_OFF) target_state = PILOTWIRE_STATUS_OFF;

  // else if status is ON
  else if (pilotwire_status.device_mode == PILOTWIRE_STATUS_ON) target_state = PILOTWIRE_STATUS_ON;

  // else thermostat mode, check according to target temperature
  else
  {
    // get current target temperature
    target_temp = PilotwireGetCurrentTargetTemperature ();

    // if temperature is too low, target state is on
    if (pilotwire_temperature.current < (target_temp - PILOTWIRE_TEMP_THRESHOLD)) target_state = PILOTWIRE_STATUS_ON;

    // else, if too high, target state is off
    else if (pilotwire_temperature.current > (target_temp + PILOTWIRE_TEMP_THRESHOLD)) target_state = PILOTWIRE_STATUS_OFF;
  }

  // if device target state has changed
  if (target_state != pilotwire_status.device_state) PilotwireSetDeviceState (target_state);

  // -----------------------
  //   Update heating state
  // -----------------------

  // if device is offloaded, target state is off
  if (is_offloaded) target_heating = PILOTWIRE_HEATING_OFFLOAD;
  else if (pilotwire_window.opened) target_heating = PILOTWIRE_HEATING_WINDOW;
  else if (target_state == PILOTWIRE_STATUS_ON) target_heating = PILOTWIRE_HEATING_ON;
  else target_heating = PILOTWIRE_HEATING_OFF;

  // update heating state
  if (target_heating != pilotwire_status.heating_mode)
  {
    pilotwire_status.heating_mode = target_heating;
    pilotwire_status.json_update  = true;
  }

  // ---------------
  //   Update JSON
  // ---------------

  // if needed, publish new state
  if (pilotwire_status.json_update) PilotwireShowJSON (true);
}

// called every second, to update
//  - temperature
//  - presence detection
//  - graph data
void PilotwireEverySecond ()
{
  uint32_t counter;

  // update temperature and update JSON if temperature has changed of more than 0.1°C
  pilotwire_temperature.current = PilotwireGetTemperature ();
  if (abs (pilotwire_status.json_temperature - pilotwire_temperature.current) > 0.1)
  {
    pilotwire_status.json_temperature = pilotwire_temperature.current;
    pilotwire_status.json_update      = true;
  }

  // if next mode is defined, set next mode as target
  if (pilotwire_status.next_time < LocalTime ()) PilotwireSetStatusMode (pilotwire_status.next_mode);

  // update movement detection
  if (pilotwire_config.mvt_detect && pilotwire_mvt.present) PilotwireMovementUpdateDetection ();

  // update window open detection
  if (pilotwire_config.window_open) PilotwireWindowUpdateDetection ();

  // loop thru the periods, to update graph data to the max on the period
  for (counter = 0; counter < PILOTWIRE_PERIOD_MAX; counter++)
  {
    // update graph temperature for current period (keep minimal value)
    if (isnan (pilotwire_graph.temperature[counter])) pilotwire_graph.temperature[counter] = pilotwire_temperature.current;
    else if (!isnan (pilotwire_temperature.current)) pilotwire_graph.temperature[counter] = min (pilotwire_graph.temperature[counter], pilotwire_temperature.current);

    // update device state
    if (pilotwire_graph.device_state[counter] != PILOTWIRE_STATUS_ON) pilotwire_graph.device_state[counter] = pilotwire_status.device_state;

    // increment delay counter and if delay reached, update history data
    pilotwire_graph.counter[counter] = pilotwire_graph.counter[counter] % ARR_PILOTWIRE_PERIOD_SAMPLE[counter];
    if (pilotwire_graph.counter[counter] == 0) PilotwireUpdateGraph (counter);
    pilotwire_graph.counter[counter]++;
  }
}

void PilotwireInit ()
{
  uint32_t index, count;

  // offload : module is not managing the relay
  OffloadSetManagedMode (false);

  // disable JSON for Timezone module
  TimezoneEnableJSON (false);

  // disable JSON for IP address module
  IPAddressEnableJSON (false);

  // set MQTT message only for switch 1 (movement detection)
  Settings->switchmode[0] = 15;

  // disable reset 1 with button multi-press (SetOption1)
  Settings->flag.button_restrict = 1;

  // temperature : check if sensor is local
  if (PinUsed (GPIO_DSB)) pilotwire_temperature.source = GPIO_DSB;
  else if (PinUsed (GPIO_DHT11)) pilotwire_temperature.source = GPIO_DHT11;
  else if (PinUsed (GPIO_DHT22)) pilotwire_temperature.source = GPIO_DHT22;
  else if (PinUsed (GPIO_SI7021)) pilotwire_temperature.source = GPIO_SI7021;

  // temparature : if needed, set DS18B20 pullup flag (SetOption74)
  if (pilotwire_temperature.source == GPIO_DSB) Settings->flag3.ds18x20_internal_pullup = 1;

  // init movement detection data
//  pilotwire_mvt.last    = UINT32_MAX;
  pilotwire_mvt.present = PinUsed (GPIO_SWT1, 0);

  // offload : remove all device types, declare available device types and set default as room heater
  OffloadResetAvailableType ();
  OffloadAddAvailableType (OFFLOAD_DEVICE_ROOM);
  OffloadAddAvailableType (OFFLOAD_DEVICE_OFFICE);
  OffloadAddAvailableType (OFFLOAD_DEVICE_LIVING);
  OffloadAddAvailableType (OFFLOAD_DEVICE_BATHROOM);
  OffloadAddAvailableType (OFFLOAD_DEVICE_KITCHEN);

  // initialise graph data per period
  for (index = 0; index < PILOTWIRE_PERIOD_MAX; index++)
  {
    // main grah data
    pilotwire_graph.index[index]        = 0;
    pilotwire_graph.counter[index]      = 0;
    pilotwire_graph.temperature[index]  = NAN;
    pilotwire_graph.device_state[index] = UINT8_MAX;

    // initialise temperature graph
    for (count = 0; count < PILOTWIRE_GRAPH_SAMPLE; count++)
    {
      pilotwire_graph.arr_temp[index][count]   = SHRT_MAX;
      pilotwire_graph.arr_target[index][count] = SHRT_MAX;
      pilotwire_graph.arr_state[index][count]  = UINT8_MAX;
    }
  }

  // initialise open window detection temperature array
  for (index = 0; index < PILOTWIRE_WINDOW_SAMPLE_NBR; index++) pilotwire_window.arr_temp[index] = NAN;

  // load configuration
  PilotwireLoadConfig ();
}

// get source of temperature
float PilotwireGetTemperature ()
{
  uint32_t index;
  float    temperature = NAN;

  // if local sensor DS18B20
  if (pilotwire_temperature.source == GPIO_DSB)
  {
    index = ds18x20_sensor[0].index;
    if (ds18x20_sensor[index].valid) temperature = ds18x20_sensor[index].temperature;
  }

  // else if local sensor DHT11, AM2301 (DHT21, DHT22, AM2302, AM2321), SI7021
  else if ((pilotwire_temperature.source == GPIO_DHT11) || (pilotwire_temperature.source == GPIO_DHT22) || (pilotwire_temperature.source == GPIO_SI7021))
  {
    temperature = Dht[0].t;
  }

  // else try remote sensor
  else
  {
    // read temperature from remote
    temperature = RemoteGetValue ();

    // if tepmperature read, set source
    if (!isnan (temperature)) pilotwire_temperature.source = GPIO_MAX;
  }

  // truncate temperature to 0.1 °C
  if (!isnan (temperature)) temperature = round (temperature * 10) / 10;

  return temperature;
}

// get source of temperature
void PilotwireGetTemperatureSource (char *pstr_source, size_t size_source)
{
  // verification
  if (pstr_source == nullptr) return;

  // generate answer
  if (pilotwire_temperature.source == UINT32_MAX) strlcpy (pstr_source, D_PILOTWIRE_SOURCE_UNDEFINED, size_source);
  else if (pilotwire_temperature.source == GPIO_MAX) strlcpy (pstr_source, D_PILOTWIRE_SOURCE_REMOTE, size_source);
  else strlcpy (pstr_source, D_PILOTWIRE_SOURCE_LOCAL, size_source);
}


/***********************************************\
 *                    Web
\***********************************************/

#ifdef USE_WEBSERVER

// heater status
void PilotwireWebIconNone ()    { Webserver->send (200, "image/png", pilotwire_none_png,    pilotwire_none_len);    }
void PilotwireWebIconFlame ()   { Webserver->send (200, "image/png", pilotwire_flame_png,   pilotwire_flame_len);   }
void PilotwireWebIconWindow ()  { Webserver->send (200, "image/png", pilotwire_window_png,  pilotwire_window_len);  }
void PilotwireWebIconMove ()    { Webserver->send (200, "image/png", pilotwire_move_png,    pilotwire_move_len);    }
void PilotwireWebIconOff ()     { Webserver->send (200, "image/png", pilotwire_off_png,     pilotwire_off_len);     }
void PilotwireWebIconForced ()  { Webserver->send (200, "image/png", pilotwire_forced_png,  pilotwire_forced_len);  }
void PilotwireWebIconNormal ()  { Webserver->send (200, "image/png", pilotwire_normal_png,  pilotwire_normal_len);  }
void PilotwireWebIconNight ()   { Webserver->send (200, "image/png", pilotwire_night_png,   pilotwire_night_len);   }
void PilotwireWebIconNobody ()  { Webserver->send (200, "image/png", pilotwire_nobody_png,  pilotwire_nobody_len);  }
void PilotwireWebIconVacancy () { Webserver->send (200, "image/png", pilotwire_vacancy_png, pilotwire_vacancy_len); }

// get window or flame icon
void PilotwireIconHeater (char* pstr_icon, size_t size_icon)
{
  // verification
  if (pstr_icon == nullptr) return;

  // get icon
  if (pilotwire_window.opened) strlcpy (pstr_icon, PILOTWIRE_ICON_WINDOW, size_icon);
  else if (pilotwire_status.device_state == PILOTWIRE_STATUS_ON) strlcpy (pstr_icon, PILOTWIRE_ICON_FLAME, size_icon);
  else if (pilotwire_mvt.active) strlcpy (pstr_icon, PILOTWIRE_ICON_MOVE, size_icon);
  else strlcpy (pstr_icon, PILOTWIRE_ICON_NONE, size_icon);
}

// get status icon
void PilotwireIconStatus (char* pstr_icon, size_t size_icon)
{
  // verification
  if (pstr_icon == nullptr) return;

  // if device is offloaded
  if (OffloadIsOffloaded ()) strlcpy (pstr_icon, OFFLOAD_ICON_ACTIVE, size_icon);

  // else display icon according to mode
  else switch (pilotwire_status.device_mode)
  {
    case PILOTWIRE_STATUS_OFF: strlcpy (pstr_icon, PILOTWIRE_ICON_OFF, size_icon); break;
    case PILOTWIRE_STATUS_ON: strlcpy (pstr_icon, PILOTWIRE_ICON_FORCED, size_icon); break;
    case PILOTWIRE_STATUS_NORMAL: strlcpy (pstr_icon, PILOTWIRE_ICON_NORMAL, size_icon); break;
    case PILOTWIRE_STATUS_NIGHT: strlcpy (pstr_icon, PILOTWIRE_ICON_NIGHT, size_icon);  break;
    case PILOTWIRE_STATUS_NOBODY: strlcpy (pstr_icon, PILOTWIRE_ICON_NOBODY, size_icon); break;
    case PILOTWIRE_STATUS_VACANCY: strlcpy (pstr_icon, PILOTWIRE_ICON_VACANCY, size_icon); break;
    default: strlcpy (pstr_icon, PILOTWIRE_ICON_NONE, size_icon); break;
  }
}

// append pilot wire state to main page
void PilotwireWebSensor ()
{
  float temperature;
  char  str_value[8];
  char  str_text[32];
  char  str_title[64];

  // set title according to sensor source (no source available, local or remote)
  PilotwireGetTemperatureSource (str_text, sizeof (str_text));
  sprintf_P (str_title, PSTR ("%s <small><i>(%s)</i></small>"), D_PILOTWIRE_TEMPERATURE, str_text);

  // generate current temperature string in bold
  if (isnan (pilotwire_temperature.current)) strcpy_P (str_value, PSTR ("---"));
    else ext_snprintf_P (str_value, sizeof(str_value), PSTR ("%01_f"), &pilotwire_temperature.current);
  sprintf_P (str_text, PSTR ("<b>%s</b>"), str_value);

  // if target temperature is defined in current running status
  if (pilotwire_status.device_mode >= PILOTWIRE_STATUS_NORMAL)
  {
    temperature = PilotwireGetCurrentTargetTemperature ();
    ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%01_f"), &temperature);
    strcat_P (str_text, PSTR (" / "));
    strlcat (str_text, str_value, sizeof (str_text));
  }

  // add temperature unit
  strlcat (str_text, " ", sizeof (str_text));
  strlcat (str_text, remote_status.str_unit_temp, sizeof (str_text));

  // display temperature
  WSContentSend_PD (PSTR ("{s}%s{m}%s{e}\n"), str_title, str_text);

  // display config and status mode
  GetTextIndexed (str_title, sizeof (str_title), pilotwire_config.device_mode, kPilotwireConfig);
  GetTextIndexed (str_text, sizeof (str_text), pilotwire_status.device_mode, kPilotwireStatus);
  WSContentSend_PD (PSTR ("{s}%s{m}%s{e}\n"), str_title, str_text);

  // if movement detection is enabled
  if (pilotwire_config.mvt_detect && pilotwire_mvt.present)
  {
    if (pilotwire_mvt.last == UINT32_MAX) strcpy (str_text, "---");
      else OffloadGenerateTime (str_text, sizeof (str_text), LocalTime () - pilotwire_mvt.last);
    WSContentSend_PD (PSTR ("{s}%s{m}%s{e}\n"), D_PILOTWIRE_MOVEMENT, str_text);
  }
}

// intermediate page to update selected status from main page
void PilotwireWebPageSwitchStatus ()
{
  char str_argument[16];

  // if access not allowed, close
  if (!HttpCheckPriviledgedAccess()) return;

  // check for 'therm' parameter
  WebGetArg (D_CMND_PILOTWIRE_STATUS, str_argument, sizeof (str_argument));
  if (strlen (str_argument) > 0) PilotwireSetStatusMode ((uint8_t)atoi (str_argument), true);

  // auto reload root page with dark background
  WSContentStart_P (D_PILOTWIRE_CONTROL, false);
  WSContentSend_P (PSTR ("</script>\n"));
  WSContentSend_P (PSTR ("<meta http-equiv='refresh' content='0;URL=/' />\n"));
  WSContentSend_P (PSTR ("</head>\n"));
  WSContentSend_P (PSTR ("<body bgcolor='#303030'></body>\n"));
  WSContentSend_P (PSTR ("</html>\n"));
  WSContentEnd ();
}

// add buttons on main page
void PilotwireWebMainButton ()
{
  uint32_t index;
  char     str_value[16];
  char     str_text[32];

  // control button
  WSContentSend_P (PSTR ("<p><form action='%s' method='get'><button>%s</button></form></p>\n"), D_PAGE_PILOTWIRE_CONTROL, D_PILOTWIRE_CONTROL);

  // graph button
  WSContentSend_P (PSTR ("<p><form action='%s' method='get'><button>%s</button></form></p>\n"), D_PAGE_PILOTWIRE_GRAPH, D_PILOTWIRE_GRAPH);

  // status mode options
  WSContentSend_P (PSTR ("<p><form action='%s' method='get'>\n"), D_PAGE_PILOTWIRE_STATUS);
  WSContentSend_P (PSTR ("<select style='width:100%%;text-align:center;padding:8px;border-radius:0.3rem;' name='%s' onchange='this.form.submit();'>\n"), D_CMND_PILOTWIRE_STATUS, pilotwire_status.device_mode);
  WSContentSend_P (PSTR ("<option value='%d' %s>%s</option>\n"), UINT8_MAX, "", PSTR ("-- Select mode --"));
  for (index = 0; index < PILOTWIRE_STATUS_MAX; index ++)
  {
    // status label
    GetTextIndexed (str_text, sizeof (str_text), index, kPilotwireStatus);

    // get temperature
    if (index >= PILOTWIRE_STATUS_NORMAL)
    {
      ext_snprintf_P (str_value, sizeof (str_value), PSTR (" (%01_f)"), &pilotwire_config.arr_target[index]);
      strlcat (str_text, str_value, sizeof (str_text));
    } 

    // display status mode
    WSContentSend_P (PSTR ("<option value='%d' %s>%s</option>\n"), index, "", str_text);
  }
  WSContentSend_P (PSTR ("</select>\n"));
  WSContentSend_P (PSTR ("</form></p>\n"));
}

// Pilotwire heater configuration web page
void PilotwireWebPageConfigure ()
{
  uint8_t value;
  float   temperature;
  char    str_argument[24];
  char    str_value[16];
  char    str_step[8];

  // if access not allowed, close
  if (!HttpCheckPriviledgedAccess()) return;

  // page comes from save button on configuration page
  if (Webserver->hasArg (F ("save")))
  {
    // get pilotwire device type according to 'type' parameter
    WebGetArg (D_CMND_PILOTWIRE_TYPE, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetDeviceType ((uint8_t)atoi (str_argument), false);

    // get pilotwire mode according to 'mode' parameter
    WebGetArg (D_CMND_PILOTWIRE_MODE, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetConfigMode ((uint8_t)atoi (str_argument), false);

    // get pilotwire open window detection setting according to 'window' parameter
    WebGetArg (D_CMND_PILOTWIRE_WINDOW, str_argument, sizeof (str_argument));
    pilotwire_config.window_open = (strcmp (str_argument, "on") == 0);

    // get pilotwire movement detection setting according to 'mvt' parameter
    WebGetArg (D_CMND_PILOTWIRE_MVT, str_argument, sizeof (str_argument));
    pilotwire_config.mvt_detect = (strcmp (str_argument, "on") == 0);

    // get minimum temperature according to 'tlow' parameter
    WebGetArg (D_CMND_PILOTWIRE_LOW, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_LOW, atof (str_argument), false);

    // get minimum temperature according to 'thigh' parameter
    WebGetArg (D_CMND_PILOTWIRE_HIGH, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_HIGH, atof (str_argument), false);

    // get normal mode temperature according to 'tnormal' parameter
    WebGetArg (D_CMND_PILOTWIRE_NORMAL, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NORMAL, atof (str_argument), false);

    // get night mode temperature according to 'tnight' parameter
    WebGetArg (D_CMND_PILOTWIRE_NIGHT, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NIGHT, atof (str_argument), false);

    // get minimum temperature according to 'tnobody' parameter
    WebGetArg (D_CMND_PILOTWIRE_NOBODY, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_NOBODY, atof (str_argument), false);

    // get minimum temperature according to 'tvacancy' parameter
    WebGetArg (D_CMND_PILOTWIRE_VACANCY, str_argument, sizeof (str_argument));
    if (strlen (str_argument) > 0) PilotwireSetTemperature (PILOTWIRE_TEMP_VACANCY, atof (str_argument), false);

    // save configuration
    PilotwireSaveConfig ();
  }

  // get step temperature
  temperature = PILOTWIRE_TEMP_STEP;
  ext_snprintf_P (str_step, sizeof (str_step), PSTR ("%1_f"), &temperature);

  // beginning of form
  WSContentStart_P (D_PILOTWIRE_CONFIGURE " " D_PILOTWIRE);
  WSContentSendStyle ();
  WSContentSend_P (PSTR ("<style>\n"));
//  WSContentSend_P (PSTR ("p.half {display:inline-block;width:47%%;max-width:500px;margin-right:2%%;}\n"));
  WSContentSend_P (PSTR ("span.key {float:right;font-size:0.7rem;}\n"));
  WSContentSend_P (PSTR ("</style>\n"));

  WSContentSend_P (PSTR ("<form method='get' action='%s'>\n"), D_PAGE_PILOTWIRE_CONFIG);

  //    Device type 
  // -----------------

  WSContentSend_P (D_CONF_FIELDSET_START, D_PILOTWIRE_CONNEXION);
//  WSContentSend_P (PSTR ("<p>\n"));

  // command type selection
  if (pilotwire_config.device_type == PILOTWIRE_DEVICE_NORMAL) strcpy_P (str_argument, PSTR (D_PILOTWIRE_CHECKED)); else strcpy (str_argument, "");
  WSContentSend_P (PSTR ("<input type='radio' id='normal' name='%s' value=%d %s>%s<br>\n"), D_CMND_PILOTWIRE_TYPE, PILOTWIRE_DEVICE_NORMAL, str_argument, D_PILOTWIRE);
  if (pilotwire_config.device_type == PILOTWIRE_DEVICE_DIRECT) strcpy_P (str_argument, PSTR (D_PILOTWIRE_CHECKED)); else strcpy (str_argument, "");
  WSContentSend_P (PSTR ("<input type='radio' id='direct' name='%s' value=%d %s>%s<br>\n"), D_CMND_PILOTWIRE_TYPE, PILOTWIRE_DEVICE_DIRECT, str_argument, D_PILOTWIRE_DIRECT);

//  WSContentSend_P (PSTR ("</p>\n"));
  WSContentSend_P (D_CONF_FIELDSET_STOP);

  //    Config Mode 
  // -----------------

  WSContentSend_P (D_CONF_FIELDSET_START, D_PILOTWIRE_MODE);
  WSContentSend_P (PSTR ("<span class='key'>%s</span>\n"), D_CMND_PILOTWIRE_MODE);

  // loop thru different modes
  for (value = 0; value < PILOTWIRE_CONFIG_MAX; value ++)
  { 
    if (pilotwire_config.device_mode == value) strcpy_P (str_argument, PSTR (D_PILOTWIRE_CHECKED)); else strcpy (str_argument, "");
    GetTextIndexed (str_value, sizeof (str_value), value, kPilotwireConfig);
    WSContentSend_P (D_CONF_MODE_SELECT, D_CMND_PILOTWIRE_MODE, value, value, str_argument, str_value);
  }

// WSContentSend_P (PSTR ("</p>\n"));

  WSContentSend_P (D_CONF_FIELDSET_STOP);

  //   Options
  //    - Window open
  //    - Mvt detect
  // ------------------

  WSContentSend_P (D_CONF_FIELDSET_START, D_PILOTWIRE_OPTION);

  if (pilotwire_config.window_open) strcpy (str_value, D_PILOTWIRE_CHECKED); else strcpy (str_value, "");
  WSContentSend_P (PSTR ("<p><input type='checkbox' id='%s' name='%s' %s>\n"), D_CMND_PILOTWIRE_WINDOW, D_CMND_PILOTWIRE_WINDOW, str_value);
  WSContentSend_P (PSTR ("<label for='%s'>%s</label></p>\n"), D_CMND_PILOTWIRE_WINDOW, D_PILOTWIRE_WINDOW);

  if (pilotwire_config.mvt_detect) strcpy (str_value, D_PILOTWIRE_CHECKED); else strcpy (str_value, "");
  WSContentSend_P (PSTR ("<p><input type='checkbox' id='%s' name='%s' %s>\n"), D_CMND_PILOTWIRE_MVT, D_CMND_PILOTWIRE_MVT, str_value);
  WSContentSend_P (PSTR ("<label for='%s'>%s</label></p>\n"), D_CMND_PILOTWIRE_MVT, D_PILOTWIRE_MVT);

  WSContentSend_P (D_CONF_FIELDSET_STOP);

  //   Temperatures 
  // ----------------

  strlcpy (str_argument, D_PILOTWIRE_TEMPERATURE, sizeof (str_argument));
  strlcat (str_argument, " (", sizeof (str_argument));
  strlcat (str_argument, remote_status.str_unit_temp, sizeof (str_argument));
  strlcat (str_argument, ")", sizeof (str_argument));
  WSContentSend_P (D_CONF_FIELDSET_START, str_argument);

  // minimum temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_LOW, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_LOW, D_CMND_PILOTWIRE_LOW, PILOTWIRE_TEMP_LIMIT_MIN, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  // maximum temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_HIGH, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_HIGH, D_CMND_PILOTWIRE_HIGH, PILOTWIRE_TEMP_LIMIT_MIN, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  // normal temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_NORMAL, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_NORMAL]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_NORMAL, D_CMND_PILOTWIRE_NORMAL, PILOTWIRE_TEMP_LIMIT_MIN, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  // night temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_NIGHT, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_NIGHT]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_NIGHT, D_CMND_PILOTWIRE_NIGHT, - PILOTWIRE_TEMP_LIMIT_MAX, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  // nobody temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_NOBODY, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_NOBODY]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_NOBODY, D_CMND_PILOTWIRE_NOBODY, - PILOTWIRE_TEMP_LIMIT_MAX, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  // vacancy temperature
  GetTextIndexed (str_argument, sizeof (str_argument), PILOTWIRE_TEMP_VACANCY, kPilotwireTemperature);
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &pilotwire_config.arr_target[PILOTWIRE_TEMP_VACANCY]);
  WSContentSend_P (D_CONF_FIELD_FULL, str_argument, D_CMND_PILOTWIRE_VACANCY, D_CMND_PILOTWIRE_VACANCY, - PILOTWIRE_TEMP_LIMIT_MAX, PILOTWIRE_TEMP_LIMIT_MAX, str_step, str_value);

  WSContentSend_P (D_CONF_FIELDSET_STOP);

  WSContentSend_P (PSTR ("<br>\n"));

  // save button
  WSContentSend_P (PSTR ("<p><button name='save' type='submit' class='button bgrn'>%s</button></p>\n"), D_SAVE);
  WSContentSend_P (PSTR ("</form>\n"));

  // configuration button
  WSContentSpaceButton (BUTTON_CONFIGURATION);

  // end of page
  WSContentStop ();
}

// Temperature graph frame
void PilotwireWebGraphFrame ()
{
  float temperature;
  char  str_value[8];

  // start of SVG graph
  WSContentBegin (200, CT_HTML);
  WSContentSend_P (PSTR ("<svg viewBox='0 0 %d %d' preserveAspectRatio='xMinYMinmeet'>\n"), PILOTWIRE_GRAPH_WIDTH, PILOTWIRE_GRAPH_HEIGHT);

  // SVG style 
  WSContentSend_P (PSTR ("<style type='text/css'>\n"));
  WSContentSend_P (PSTR ("rect {stroke:grey;fill:none;}\n"));
  WSContentSend_P (PSTR ("line.dash {stroke:grey;stroke-dasharray:8;}\n"));
  WSContentSend_P (PSTR ("text.temperature {font-size:18px;fill:yellow;}\n"));
  WSContentSend_P (PSTR ("</style>\n"));

  // graph curve zone
  WSContentSend_P (PSTR ("<rect x='%d%%' y='0%%' width='%d%%' height='100%%' rx='10' />\n"), PILOTWIRE_GRAPH_PERCENT_START, PILOTWIRE_GRAPH_PERCENT_STOP - PILOTWIRE_GRAPH_PERCENT_START);

  // graph temperature units
  temperature = pilotwire_graph.temp_max;
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  WSContentSend_P (D_GRAPH_TEMPERATURE, 1, 4, str_value);
  temperature = pilotwire_graph.temp_min + (pilotwire_graph.temp_max - pilotwire_graph.temp_min) * 0.75;
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  WSContentSend_P (D_GRAPH_TEMPERATURE, 1, 27, str_value);
  temperature = pilotwire_graph.temp_min + (pilotwire_graph.temp_max - pilotwire_graph.temp_min) * 0.50;
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  WSContentSend_P (D_GRAPH_TEMPERATURE, 1, 52, str_value);
  temperature = pilotwire_graph.temp_min + (pilotwire_graph.temp_max - pilotwire_graph.temp_min) * 0.25;
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  WSContentSend_P (D_GRAPH_TEMPERATURE, 1, 77, str_value);
  temperature = pilotwire_graph.temp_min;
  ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%1_f"), &temperature);
  WSContentSend_P (D_GRAPH_TEMPERATURE, 1, 99, str_value);

  // graph separation lines
  WSContentSend_P (D_GRAPH_SEPARATION, PILOTWIRE_GRAPH_PERCENT_START, 25, PILOTWIRE_GRAPH_PERCENT_STOP, 25);
  WSContentSend_P (D_GRAPH_SEPARATION, PILOTWIRE_GRAPH_PERCENT_START, 50, PILOTWIRE_GRAPH_PERCENT_STOP, 50);
  WSContentSend_P (D_GRAPH_SEPARATION, PILOTWIRE_GRAPH_PERCENT_START, 75, PILOTWIRE_GRAPH_PERCENT_STOP, 75);

  // end of SVG graph
  WSContentSend_P (PSTR ("</svg>\n"));
  WSContentEnd ();
}

// Temperature graph data
void PilotwireWebGraphData ()
{
  int      unit_width, shift_unit, shift_width;
  int      graph_x, graph_left, graph_right, graph_width, graph_low, graph_high;
  float    graph_y, value, temp_scope;
  TIME_T   current_dst;
  uint32_t current_time;
  uint32_t index, array_index;

  // validature min and max temperature difference
  temp_scope = pilotwire_graph.temp_max - pilotwire_graph.temp_min;
  if (temp_scope == 0) return;

  // start of SVG graph
  WSContentBegin(200, CT_HTML);
  WSContentSend_P (PSTR ("<svg viewBox='0 0 %d %d' preserveAspectRatio='xMinYMinmeet'>\n"), PILOTWIRE_GRAPH_WIDTH, PILOTWIRE_GRAPH_HEIGHT);

  // SVG style 
  WSContentSend_P (PSTR ("<style type='text/css'>\n"));
  WSContentSend_P (PSTR ("polyline.temperature {fill:none;stroke:yellow;stroke-width:2;}\n"));
  WSContentSend_P (PSTR ("polyline.target {fill:none;stroke:orange;stroke-dasharray:4;}\n"));
  WSContentSend_P (PSTR ("polyline.state {fill:none;stroke:white;stroke-width:2;}\n"));
  WSContentSend_P (PSTR ("line.time {stroke:white;}\n"));
  WSContentSend_P (PSTR ("text.time {font-size:16px;fill:white;}\n"));
  WSContentSend_P (PSTR ("</style>\n"));

  // boundaries of SVG graph
  graph_left  = PILOTWIRE_GRAPH_PERCENT_START * PILOTWIRE_GRAPH_WIDTH / 100;
  graph_right = PILOTWIRE_GRAPH_PERCENT_STOP * PILOTWIRE_GRAPH_WIDTH / 100;
  graph_width = graph_right - graph_left;

  // --------------------------
  //    Pilotwire state curve
  // --------------------------

  // loop for the pilotwire state (white curve)
  graph_low  = 100 * PILOTWIRE_GRAPH_HEIGHT / 100;
  graph_high = 95 * PILOTWIRE_GRAPH_HEIGHT / 100;
  WSContentSend_P (PSTR ("<polyline class='state' points='"));
  for (index = 0; index < PILOTWIRE_GRAPH_SAMPLE; index++)
  {
    // if state has been defined
    array_index = (index + pilotwire_graph.index[0]) % PILOTWIRE_GRAPH_SAMPLE;
    if (pilotwire_graph.arr_state[0][array_index] != UINT8_MAX)
    {
      // calculate end point x and y
      graph_x = graph_left + (graph_width * index / PILOTWIRE_GRAPH_SAMPLE);

      // add the point to the line
      if (pilotwire_graph.arr_state[0][array_index] == PILOTWIRE_STATUS_ON) WSContentSend_P (PSTR ("%d,%d "), graph_x, graph_high);
      else WSContentSend_P (PSTR ("%d,%d "), graph_x, graph_low);
    }
  }
  WSContentSend_P (PSTR ("'/>\n"));

  // ----------------------------
  //   Target Temperature curve
  // ----------------------------

  // loop for the target temperature graph
  WSContentSend_P (PSTR ("<polyline class='target' points='"));
  for (index = 0; index < PILOTWIRE_GRAPH_SAMPLE; index++)
  {
    // get target temperature value and set to minimum if not defined
    array_index = (index + pilotwire_graph.index[0]) % PILOTWIRE_GRAPH_SAMPLE;
    if (pilotwire_graph.arr_target[0][array_index] != SHRT_MAX)
    {
      // read indexed temperature
      value = (float)pilotwire_graph.arr_target[0][array_index];
      value = value / 10;

      // calculate end point x and y
      graph_x = graph_left + (graph_width * index / PILOTWIRE_GRAPH_SAMPLE);
      graph_y = (1 - ((value - pilotwire_graph.temp_min) / temp_scope)) * PILOTWIRE_GRAPH_HEIGHT;

      // add the point to the line
      WSContentSend_P (PSTR ("%d,%d "), graph_x, int (graph_y));
    }
  }
  WSContentSend_P (PSTR ("'/>\n"));

  // ---------------------
  //   Temperature curve
  // ---------------------

  // loop for the temperature graph
  WSContentSend_P (PSTR ("<polyline class='temperature' points='"));
  for (index = 0; index < PILOTWIRE_GRAPH_SAMPLE; index++)
  {
    // if temperature value is defined
    array_index = (index + pilotwire_graph.index[0]) % PILOTWIRE_GRAPH_SAMPLE;
    if (pilotwire_graph.arr_temp[0][array_index] != SHRT_MAX)
    {
      // read indexed temperature
      value = (float)pilotwire_graph.arr_temp[0][array_index];
      value = value / 10;

      // calculate end point x and y
      graph_x = graph_left + (graph_width * index / PILOTWIRE_GRAPH_SAMPLE);
      graph_y  = (1 - ((value - pilotwire_graph.temp_min) / temp_scope)) * PILOTWIRE_GRAPH_HEIGHT;

      // add the point to the line
      WSContentSend_P (PSTR ("%d,%d "), graph_x, int (graph_y));
    }
  }
  WSContentSend_P (PSTR ("'/>\n"));

  // ---------------
  //   Time line
  // ---------------

  // get current time
  current_time = LocalTime ();
  BreakTime (current_time, current_dst);

  // calculate horizontal shift
  unit_width  = graph_width / 6;
  shift_unit  = current_dst.hour % 4;
  shift_width = unit_width - (unit_width * shift_unit / 4) - (unit_width * current_dst.minute / 240);

  // calculate first time displayed by substracting (5 * 4h + shift) to current time
  current_time -= (5 * 14400) + (shift_unit * 3600); 

  // display 4 hours separation lines with hour
  for (index = 0; index < 6; index++)
  {
    // convert back to date and increase time of 4h
    BreakTime (current_time, current_dst);
    current_time += 14400;

    // display separation line and time
    graph_x = graph_left + shift_width + (index * unit_width);
    WSContentSend_P (PSTR ("<line class='time' x1='%d' y1='%d%%' x2='%d' y2='%d%%' />\n"), graph_x, 49, graph_x, 51);
    WSContentSend_P (PSTR ("<text class='time' x='%d' y='%d%%'>%02dh</text>\n"), graph_x - 15, 55, current_dst.hour);
  }

  // end of SVG graph
  WSContentSend_P (PSTR ("</svg>\n"));
  WSContentEnd();
}

// Get temperature attributes according to target temperature
void PilotwireGetTemperatureClass (float temperature, char* pstr_class, size_t size_class)
{
  float target;

  // check
  if ((pstr_class == nullptr) || isnan (temperature)) return;
  strcpy (pstr_class, "");

  // if status is not OFF, set attributes
  if (pilotwire_status.device_mode != PILOTWIRE_STATUS_OFF)
  {
    // get current target
    target = PilotwireGetCurrentTargetTemperature ();

    // if lower or equal to target temperature set status as active
    if (temperature <= target)
    {
      // set active display
      strlcat (pstr_class, " tget", size_class);

      // set temperature color code
      if (temperature <= PILOTWIRE_TEMP_SCALE_LOW) strlcat (pstr_class, " low", size_class);
      else if (temperature >= PILOTWIRE_TEMP_SCALE_HIGH) strlcat (pstr_class, " high", size_class);
      else strlcat (pstr_class, " mid", size_class);
    }
  }
}

// get status update
void PilotwireWebUpdate ()
{
  float delta, range;
  char  str_text[16];
  char  str_update[64];

  // update current temperature
  if (!isnan (pilotwire_temperature.current)) ext_snprintf_P (str_update, sizeof (str_update), PSTR ("%1_f"), &pilotwire_temperature.current);
    else strcpy_P (str_update, PSTR ("---"));

  // update target temperature
  delta = PilotwireGetCurrentTargetTemperature ();
  if (!isnan (delta)) ext_snprintf_P (str_text, sizeof (str_text), PSTR ("%1_f"), &delta);
    else strcpy_P (str_text, PSTR ("---"));
  strlcat (str_update, ";", sizeof (str_update));
  strlcat (str_update, str_text, sizeof (str_update));

  // display simplified mode icon name
  strlcat (str_update, ";", sizeof (str_update));
  PilotwireIconStatus (str_text, sizeof (str_text));
  strlcat (str_update, str_text, sizeof (str_update));

  // display window or flame icon
  strlcat (str_update, ";", sizeof (str_update));
  PilotwireIconHeater (str_text, sizeof (str_text));
  strlcat (str_update, str_text, sizeof (str_update));

  // temperature ring
  range = pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] - pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW];
  if (isnan (pilotwire_temperature.current)) delta = 0;
  else if (pilotwire_temperature.current < pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) delta = 0;
  else if (pilotwire_temperature.current > pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]) delta = 75;
  else delta = round (75 * (pilotwire_temperature.current - pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) / range);
  sprintf (str_text, ";%d %d", (int)delta, (int)(100 - delta));
  strlcat (str_update, str_text, sizeof (str_update));
  
  // send result
  Webserver->send (200, "text/plain", str_update, strlen (str_update));
}

// Pilot Wire heater public configuration web page
void PilotwireWebPageControl ()
{
  uint32_t index;
  float    value, target;
  float    range, delta, radian, temperature;
  float    dot_x, dot_y, dot_left, dot_top;
  char     str_value[16];
  char     str_class[32];
  char     str_line[64];

  // validate temperature range
  range = pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH] - pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW];
  if (range == 0) return;

  // if device has to be switched OFF, force status OFF
  if (Webserver->hasArg(MQTT_STATUS_OFF)) PilotwireSetStatusMode (PILOTWIRE_STATUS_OFF);

  // else, if heater has to be switched ON, force status ON
  else if (Webserver->hasArg(MQTT_STATUS_ON)) PilotwireSetStatusMode (PILOTWIRE_STATUS_NORMAL);

  // else, if target temperature has been changed
  else if (Webserver->hasArg(D_CMND_PILOTWIRE_TARGET))
  {
    WebGetArg (D_CMND_PILOTWIRE_TARGET, str_value, sizeof (str_value));
    if (strlen (str_value) > 0) PilotwireSetCurrentTarget (atof (str_value));
  }

  // beginning of page
  WSContentStart_P (D_PILOTWIRE_CONTROL, false);
  WSContentSend_P (PSTR ("</script>\n"));

  // page data refresh script
  WSContentSend_P (PSTR ("<script type='text/javascript'>\n"));
  WSContentSend_P (PSTR ("function update() {\n"));
  WSContentSend_P (PSTR ("httpUpd=new XMLHttpRequest();\n"));
  WSContentSend_P (PSTR ("httpUpd.onreadystatechange=function() {\n"));
  WSContentSend_P (PSTR (" if (httpUpd.responseText.length>0) {\n"));
  WSContentSend_P (PSTR ("  arr_param=httpUpd.responseText.split(';');\n"));
  WSContentSend_P (PSTR ("  if (arr_param[0]!='') {document.getElementById('temp').innerHTML=arr_param[0]+'<span>&nbsp;%s</span>';}\n"), remote_status.str_unit_temp);
  WSContentSend_P (PSTR ("  if (arr_param[1]!='') {document.getElementById('target').innerHTML=arr_param[1]+'<span>&nbsp;%s</span>';}\n"), remote_status.str_unit_temp);
  WSContentSend_P (PSTR ("  if (arr_param[2]!='') {document.getElementById('mode').setAttribute('src','/'+arr_param[2]);}\n"));
  WSContentSend_P (PSTR ("  if (arr_param[3]!='') {document.getElementById('heater').setAttribute('src','/'+arr_param[3]);}\n"));
  WSContentSend_P (PSTR ("  if (arr_param[4]!='') {document.getElementById('ctemp').setAttribute('stroke-dasharray',arr_param[4]);}\n"));
  WSContentSend_P (PSTR (" }\n"));
  WSContentSend_P (PSTR ("}\n"));
  WSContentSend_P (PSTR ("httpUpd.open('GET','%s',true);\n"), D_PAGE_PILOTWIRE_UPDATE);
  WSContentSend_P (PSTR ("httpUpd.send();\n"));
  WSContentSend_P (PSTR ("}\n"));
  WSContentSend_P (PSTR ("setInterval(function() {update();},2000);\n"));
  WSContentSend_P (PSTR ("</script>\n"));

  // page style
  WSContentSend_P (PSTR ("<style>\n"));

  WSContentSend_P (PSTR ("body {color:white;background-color:%s;font-family:Arial, sans-serif;text-align:center;vertical-align:middle;}\n"), PILOTWIRE_COLOR_BACKGROUND);
  WSContentSend_P (PSTR ("div.title {font-size:1.5rem;font-weight:bold;margin:10px auto;}\n"));
  WSContentSend_P (PSTR ("div.slider {position:relative;width:100%%;padding-bottom:100%%;margin:auto;margin:30px 0px;}\n"));
  WSContentSend_P (PSTR ("div.slider div {position:absolute;display:flex;justify-content:center;align-items:center;}\n"));
  WSContentSend_P (PSTR ("div.slider img {position:absolute;}\n"));
  WSContentSend_P (PSTR ("div.slider svg {position:absolute;display:flex;justify-content:center;align-items:center;left:5%%;top:5%%;width:90%%;height:90%%;transform:rotate(135deg);}\n"));
  WSContentSend_P (PSTR ("div.unit {width:10%%;height:10%%;font-size:1.2rem;display:flex;justify-content:center;align-items:center;border:1px solid grey;border-radius:50%%;background-color:%s;color:grey;}\n"), PILOTWIRE_COLOR_BACKGROUND);
  WSContentSend_P (PSTR ("div.half {width:4%%;height:4%%;border:1px solid grey;border-radius:50%%;background-color:%s;}\n"), PILOTWIRE_COLOR_BACKGROUND);
  WSContentSend_P (PSTR ("div.actual {top:30%%;left:23%%;width:60%%;font-size:4rem;text-align:center;border:none;color:yellow;}\n"));
  WSContentSend_P (PSTR ("div.actual span {font-size:3rem;}\n"));
  WSContentSend_P (PSTR ("div.target {bottom:2%%;left:30%%;width:40%%;font-size:2rem;color:grey;text-align:center;border:2px solid grey;border-radius:10px;background-color:%s;}\n"), PILOTWIRE_COLOR_BACKGROUND);
  WSContentSend_P (PSTR ("div.target span {font-size:1.5rem;}\n"));
  WSContentSend_P (PSTR ("div.tget {color:white;border-color:white;}\n"));
  WSContentSend_P (PSTR ("div.low {background:%s;}\n"), PILOTWIRE_COLOR_LOW);
  WSContentSend_P (PSTR ("div.mid {background:%s;}\n"), PILOTWIRE_COLOR_MEDIUM);
  WSContentSend_P (PSTR ("div.high {background:%s;}\n"), PILOTWIRE_COLOR_HIGH);
  WSContentSend_P (PSTR ("img.heater {left:47%%;top:15%%;width:8%%;}\n"));
  WSContentSend_P (PSTR ("img.mode {left:42%%;top:58%%;width:16%%;}\n"));
  WSContentSend_P (PSTR ("a {text-decoration:none;}\n"));

  // dots : loop to calculate position and style
  for (temperature = pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]; temperature <= pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]; temperature += 0.5)
  {
    // calculate angle
    value = floor (temperature);
    delta = temperature - pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW];
    radian = 3.9270 - (4.7124 * delta / range);
    if (radian < 0) radian += 6.2832;

    // calculate center position of the dot (in percentage)
    dot_x = 50 + (45 * cos (radian));
    dot_y = 50 - (45 * sin (radian));

    // if dealing with round unit
    if (temperature == value)
    {
      // calculate left and top position
      dot_left = dot_x - 5;
      dot_top  = dot_y - 5;

      // display position
      ext_snprintf_P (str_line, sizeof (str_line), PSTR ("div#t%0_f%s {left:%01_f%%;top:%01_f%%;}"), &temperature, "", &dot_left, &dot_top);
    }

    // else, dealing with half unit
    else
    {
      // calculate left and top position
      dot_left = dot_x - 2;
      dot_top  = dot_y - 2;

      // display position
      ext_snprintf_P (str_line, sizeof (str_line), PSTR ("div#t%0_f%s {left:%01_f%%;top:%01_f%%;}"), &value, "h", &dot_left, &dot_top);
    }

    // display line
    WSContentSend_P (PSTR ("%s\n"), str_line);
  }

  WSContentSend_P (PSTR ("</style>\n"));
  WSContentSend_P (PSTR ("</head>\n"));

  // page body
  WSContentSend_P (PSTR ("<body>\n"));

  // room name
  WSContentSend_P (PSTR ("<div class='title'>%s</div>\n"), SettingsText (SET_DEVICENAME));

  // slider
  WSContentSend_P (PSTR ("<div class='slider'>\n"));

  // global ring and actual temperature ring
  if (isnan (pilotwire_temperature.current)) delta = 0;
  else if (pilotwire_temperature.current < pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) delta = 0;
  else if (pilotwire_temperature.current > pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]) delta = 75;
  else delta = round (75 * (pilotwire_temperature.current - pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) / range);
  WSContentSend_P (PSTR ("<svg>\n"));
  WSContentSend_P (PSTR ("<circle id='cfull' stroke='grey' stroke-width=4 pathLength=100 stroke-dasharray='75 25' fill='transparent' r='50%%' cx='50%%' cy='50%%'/>\n"));
  WSContentSend_P (PSTR ("<circle id='ctemp' stroke='yellow' stroke-width=6 pathLength=100 stroke-dasharray='%d %d' fill='transparent' r='50%%' cx='50%%' cy='50%%'/>\n"), (int)delta, (int)(100 - delta));
  WSContentSend_P (PSTR ("</svg>\n"));

  // heating acive icon
  PilotwireIconHeater (str_line, sizeof (str_line));
  WSContentSend_P (PSTR ("<img class='heater' id='heater' src='/%s' />\n"), str_line);

  // device status icon
  if (pilotwire_status.device_mode != PILOTWIRE_STATUS_OFF) WSContentSend_P (PSTR ("<a href='/%s?%s'>"), D_PAGE_PILOTWIRE_CONTROL, MQTT_STATUS_OFF);
  else WSContentSend_P (PSTR ("<a href='/%s?%s'>"), D_PAGE_PILOTWIRE_CONTROL, MQTT_STATUS_ON);
  PilotwireIconStatus (str_line, sizeof (str_line));
  WSContentSend_P (PSTR ("<img class='mode' id='mode' src='/%s' />"), str_line);
  WSContentSend_P (PSTR ("</a>\n"));

  // actual temperature
  strcpy_P (str_line, PSTR ("---"));
  if (!isnan (pilotwire_temperature.current)) ext_snprintf_P (str_line, sizeof (str_line), PSTR ("%1_f"), &pilotwire_temperature.current);
  WSContentSend_P (PSTR ("<a href='/%s'><div class='actual' name='temp' id='temp'>%s<span>&nbsp;%s</span></div></a>\n"), D_PAGE_PILOTWIRE_GRAPH, str_line, remote_status.str_unit_temp);

  // target temperature
  target = PilotwireGetCurrentTargetTemperature ();
  strcpy (str_line, "");
  if (!isnan (target)) ext_snprintf_P (str_line, sizeof (str_line), PSTR ("%1_f"), &target);
  PilotwireGetTemperatureClass (target, str_class, sizeof (str_class));
  WSContentSend_P (PSTR ("<div class='target%s' name='target' id='target'>%s<span>&nbsp;%s</span></div>\n"), str_class, str_line, remote_status.str_unit_temp);

  // loop to display the temperature dots
  for (temperature = pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]; temperature <= pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]; temperature += 0.5)
  {
    // get temperature and round value
    value = floor (temperature);
    ext_snprintf_P (str_value, sizeof (str_value), PSTR ("%0_f"), &value);
    ext_snprintf_P (str_line, sizeof (str_line), PSTR ("%01_f"), &temperature);

    // set temperature class according to target
    PilotwireGetTemperatureClass (temperature, str_class, sizeof (str_class));

    // if dealing with round unit
    if (temperature == value) WSContentSend_P (PSTR ("<a href='/%s?%s=%s'><div class='unit%s' id='t%s'>%s°</div></a>\n"), D_PAGE_PILOTWIRE_CONTROL, D_CMND_PILOTWIRE_TARGET, str_line, str_class, str_value, str_value);
    
    // else dealing with half unit
    else WSContentSend_P (PSTR ("<a href='/%s?%s=%s'><div class='half%s' id='t%sh'></div></a>\n"), D_PAGE_PILOTWIRE_CONTROL, D_CMND_PILOTWIRE_TARGET, str_line, str_class, str_value);
  }

  WSContentSend_P (PSTR ("</div>\n"));      // slider

  // end of page
  WSContentStop ();
}

// Pilot Wire heater public configuration web page
void PilotwireWebPageGraph ()
{
  bool     updated = false;
  uint32_t index;
  float    value, target;
  char     str_value[8];

  // beginning of page
  WSContentStart_P (D_PAGE_PILOTWIRE_GRAPH, false);
  WSContentSend_P (PSTR ("</script>\n"));

  // set default min and max graph temperature
  pilotwire_graph.temp_min = pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW];
  pilotwire_graph.temp_max = pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH];

  // adjust to current temperature
  if (pilotwire_temperature.current < pilotwire_config.arr_target[PILOTWIRE_TEMP_LOW]) pilotwire_graph.temp_min = floor (pilotwire_temperature.current);
  if (pilotwire_temperature.current > pilotwire_config.arr_target[PILOTWIRE_TEMP_HIGH]) pilotwire_graph.temp_max = ceil (pilotwire_temperature.current);

  // loop to adjust graph min and max temperature
  for (index = 0; index < PILOTWIRE_GRAPH_SAMPLE; index++)
    if (pilotwire_graph.arr_temp[0][index] != SHRT_MAX)
    {
      // read indexed temperature
      value = (float)pilotwire_graph.arr_temp[0][index];
      value = value / 10; 

      // adjust minimum and maximum temperature
      if (pilotwire_graph.temp_min > value) pilotwire_graph.temp_min = floor (value);
      if (pilotwire_graph.temp_max < value) pilotwire_graph.temp_max = ceil  (value);
    }

  // page style
  WSContentSend_P (PSTR ("<style>\n"));
  WSContentSend_P (PSTR ("body {color:white;background-color:#252525;font-family:Arial, Helvetica, sans-serif;}\n"));
  WSContentSend_P (PSTR ("div {width:100%%;max-width:800px;margin:0.2rem auto;padding:0;text-align:center;vertical-align:middle;}\n"));

  WSContentSend_P (PSTR ("div.title {font-size:1.5rem;font-weight:bold;margin:10px auto;}\n"));

  // graph
  WSContentSend_P (PSTR (".svg-container {position:relative;vertical-align:middle;overflow:hidden;width:100%%;max-width:%dpx;padding-bottom:65%%;}\n"), PILOTWIRE_GRAPH_WIDTH);
  WSContentSend_P (PSTR (".svg-content {display:inline-block;position:absolute;top:0;left:0;}\n"));
  WSContentSend_P (PSTR ("</style>\n"));

  // page body
  WSContentSend_P (PSTR ("</head>\n"));
  WSContentSend_P (PSTR ("<body>\n"));

  // room name
  WSContentSend_P (PSTR ("<div class='title'>%s</div>\n"), SettingsText(SET_DEVICENAME));

  // graph section
  WSContentSend_P (PSTR ("<div class='svg-container'>\n"));
  WSContentSend_P (PSTR ("<object class='svg-content' id='base' type='image/svg+xml' width='%d%%' height='%d%%' data='%s'></object>\n"), 100, 100, D_PAGE_PILOTWIRE_BASE_SVG);
  WSContentSend_P (PSTR ("<object class='svg-content' id='data' type='image/svg+xml' width='%d%%' height='%d%%' data='%s'></object>\n"), 100, 100, D_PAGE_PILOTWIRE_DATA_SVG);
  WSContentSend_P (PSTR ("</div>\n"));      // svg-container

  // end of page
  WSContentSend_P (PSTR ("</form>\n"));
  WSContentStop ();
}


#endif  // USE_WEBSERVER

/***********************************************************\
 *                      Interface
\***********************************************************/

bool Xsns99 (uint8_t function)
{
  bool result = false;

  // main callback switch
  switch (function)
  {
    case FUNC_INIT:
      PilotwireInit ();
      break;
    case FUNC_COMMAND:
      result = DecodeCommand (kPilotwireCommand, PilotwireCommand);
      break;
    case FUNC_EVERY_250_MSECOND:
      PilotwireEvery250ms ();
      break;
    case FUNC_EVERY_SECOND:
      if (TasmotaGlobal.uptime > 4) PilotwireEverySecond ();
      break;
    case FUNC_SAVE_AT_MIDNIGHT:
      PilotwireRotateAtMidnight ();
      break;
    case FUNC_JSON_APPEND:
      PilotwireShowJSON (false);
      break;

#ifdef USE_WEBSERVER
    case FUNC_WEB_ADD_HANDLER:
      // pages
      Webserver->on ("/" D_PAGE_PILOTWIRE_CONFIG,   PilotwireWebPageConfigure);
      Webserver->on ("/" D_PAGE_PILOTWIRE_STATUS,   PilotwireWebPageSwitchStatus);
      Webserver->on ("/" D_PAGE_PILOTWIRE_CONTROL,  PilotwireWebPageControl);
      Webserver->on ("/" D_PAGE_PILOTWIRE_GRAPH,    PilotwireWebPageGraph);
      Webserver->on ("/" D_PAGE_PILOTWIRE_BASE_SVG, PilotwireWebGraphFrame);
      Webserver->on ("/" D_PAGE_PILOTWIRE_DATA_SVG, PilotwireWebGraphData);
      Webserver->on ("/" D_PAGE_PILOTWIRE_UPDATE,   PilotwireWebUpdate);

      // icons : basic state
      Webserver->on ("/" PILOTWIRE_ICON_NONE,       PilotwireWebIconNone);
      Webserver->on ("/" PILOTWIRE_ICON_FLAME,      PilotwireWebIconFlame);
      Webserver->on ("/" PILOTWIRE_ICON_WINDOW,     PilotwireWebIconWindow);
      Webserver->on ("/" PILOTWIRE_ICON_MOVE,       PilotwireWebIconMove);

      // icons : thermostat mode
      Webserver->on ("/" PILOTWIRE_ICON_OFF,        PilotwireWebIconOff);
      Webserver->on ("/" PILOTWIRE_ICON_FORCED,     PilotwireWebIconForced);
      Webserver->on ("/" PILOTWIRE_ICON_NORMAL,     PilotwireWebIconNormal);
      Webserver->on ("/" PILOTWIRE_ICON_NIGHT,      PilotwireWebIconNight);
      Webserver->on ("/" PILOTWIRE_ICON_NOBODY,     PilotwireWebIconNobody);
      Webserver->on ("/" PILOTWIRE_ICON_VACANCY,    PilotwireWebIconVacancy);
      break;
    case FUNC_WEB_SENSOR:
      PilotwireWebSensor ();
      break;
    case FUNC_WEB_ADD_MAIN_BUTTON:
      PilotwireWebMainButton ();
      break;
    case FUNC_WEB_ADD_BUTTON:
      WSContentSend_P (PSTR ("<p><form action='%s' method='get'><button>Configure %s</button></form></p>\n"), D_PAGE_PILOTWIRE_CONFIG, D_PILOTWIRE);
      break;
#endif  // USE_Webserver

  }
  return result;
}

#endif // USE_PILOTWIRE
